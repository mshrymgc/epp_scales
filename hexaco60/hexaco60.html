<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>HEXACO-60</title>
  <!-- jsPsych base CSS -->
  <link rel="stylesheet" href="../dist/jspsych.css" />
  <!-- Survey (for demographics only) -->
  <link rel="stylesheet" href="../dist/survey.min.css" />
  <style>
    
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Hiragino Kaku Gothic ProN', 'Yu Gothic', 'Noto Sans JP', sans-serif; }
    .note { font-size: 0.95rem; color: #333; line-height: 1.6; }
    .small { font-size: 0.85rem; }
    .muted { color:#666 }
    .footer { margin-top: 2rem; font-size: .8rem; color:#666 }
    .jspsych-content { max-width: 1150px; }
    .grid { display:grid; gap: 1rem }
    .card { background:#fff; border:1px solid #eee; border-radius:12px; padding: 1rem; box-shadow: 0 2px 10px rgba(0,0,0,.04) }
    .danger { color:#b00020 }
    details summary { cursor: pointer; }
    table { border-collapse: collapse; }
    th, td { padding: .4rem .3rem; border-bottom: 1px solid #eee; }
    /* Likert ラベルを小さめに */
    .jspsych-survey-likert .jspsych-survey-likert-opt-label { font-size: 12px; line-height: 1.2; }
    .jspsych-survey-likert .jspsych-survey-likert-statement { font-size: 0.95rem; }
    /* ===== Dark theme support (force white text on black bg) ===== */
    :root { color-scheme: light; } /* ダークモードを無効化 */
    body.dark { background:#000; color:#fff; }
    body.dark .card { background:#111; border-color:#333; color:#fff; }
    body.dark a { color:#9cd3ff; }
    body.dark .muted { color:#bbb }
    body.dark table th, body.dark table td { border-color:#333; }
    /* Chart responsive wrappers */
    .chart-wrap{ position:relative; width:100%; height:46vh; max-height:420px; }
    .chart-wrap.facet{ height:60vh; max-height:560px; }
    @media (max-width: 600px){
    .chart-wrap{ height:48vh; max-height:360px; }
    .chart-wrap.facet{ height:64vh; max-height:520px; }
    .jspsych-content { padding: 0 16px; }
    .card{ padding: .9rem; }
    .jspsych-survey-likert .jspsych-survey-likert-opt-label{ font-size: 11px; }
    .jspsych-survey-likert .jspsych-survey-likert-statement{ font-size: .95rem; }
}
  </style>

  <!-- Chart.js for radar chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- Local jsPsych core & plugins -->
  <script src="../dist/jspsych.js"></script>
  <script src="../dist/plugin-html-button-response.js"></script>
  <script src="../dist/plugin-survey.js"></script>
  <script src="../dist/plugin-survey-likert.js"></script>
  <!-- Datapipe helper -->
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe@0.5.0/dist/index.browser.min.js"></script>
</head>
<body>
  <div id="jspsych-target"></div>

  <script>
  (function(){
    // ==========================================
    // jsPsych プラグインの読み込み確認
    // ==========================================
    const { initJsPsych } = window.jsPsychModule || {};
    const jsPsychHtmlButtonResponse = window.jsPsychHtmlButtonResponse;
    const jsPsychSurvey = window.jsPsychSurvey;
    const jsPsychSurveyLikert = window.jsPsychSurveyLikert;
    const jsPsychPipe = window.jsPsychPipe;

    // 必要なコンポーネントが読み込まれているか確認
    if (!initJsPsych || !jsPsychHtmlButtonResponse || !jsPsychSurvey || !jsPsychSurveyLikert) {
      console.error('必要な jsPsych コンポーネントが読み込まれていません。dist/ 内のファイルパスを確認してください。');
      return;
    }
    if (!jsPsychPipe || typeof jsPsychPipe.saveData !== 'function') {
      console.error('jsPsych Pipe プラグインが読み込まれていません。<script src="https://unpkg.com/@jspsych-contrib/plugin-pipe@0.5.0/dist/index.browser.min.js"> を確認してください。');
      return;
    }

  // ==========================================
  // ダークテーマ設定（オプション）
  // ==========================================
  // URLパラメータに ?theme=dark がある場合のみダークモードを有効化
  (function setTheme(){
    try {
      const params = new URLSearchParams(location.search);
      if (params.get('theme') && params.get('theme').toLowerCase() === 'dark') {
        document.body.classList.add('dark');
      }
    } catch(e){}
  })();

    // ==========================================
    // 日本人ノーム（標準データ）の定義
    // ==========================================
    // 出典：Wakabayashi (2014) Japanese Psychological Research
    const normCitation = {
      label_base: '日本人サンプル（Wakabayashi, 2014, Japanese Psychological Research, Table 1）',
      url: 'https://onlinelibrary.wiley.com/doi/pdf/10.1111/jpr.12045'
    };

    // 日本人の平均値（男女別／全体）
    // 注：論文のノームはHEXACO-PI-R 100項目版の合計得点
    //     本実験はHEXACO-60項目版（項目数が異なる）のため、絶対値は参考値
    const norms = {
      // 全体の平均値
      total: {
        // 各ドメイン（因子）の平均合計得点
        domain: { 
          H: 106.6,  // 誠実-謙虚性 (Honesty-Humility)
          E: 109.9,  // 情動性 (Emotionality)
          X: 100.7,  // 外向性 (eXtraversion)
          A: 91.5,   // 協調性 (Agreeableness)
          C: 95.2,   // 勤勉性 (Conscientiousness)
          O: 100.8   // 開放性 (Openness to experience)
        },
        // 各ファセット（下位尺度）の平均値
        facet: {
          // 誠実-謙虚性のファセット
          H_Sincerity: 22.4,           // 率直さ（誠実さ）
          H_Fairness: 29.7,            // 公正さ
          H_GreedAvoidance: 25.8,      // 強欲回避
          H_Modesty: 28.7,             // 謙虚さ
          // 情動性のファセット
          E_Fearfulness: 26.3,         // 恐れやすさ
          E_Anxiety: 28.5,             // 不安傾向
          E_Dependence: 26.9,          // 依存傾向
          E_Sentimentality: 28.1,      // 感傷性
          // 外向性のファセット
          X_Expressiveness: 26.1,      // 表出性
          X_SocialBoldness: 20.8,      // 社会的大胆さ
          X_Sociability: 28.3,         // 社交性
          X_Liveliness: 25.5,          // 活発さ
          // 協調性のファセット
          A_Forgiveness: 20.0,         // 赦しやすさ
          A_Gentleness: 23.3,          // 温和さ
          A_Flexibility: 25.0,         // 柔軟さ
          A_Patience: 23.2,            // 我慢強さ
          // 勤勉性のファセット
          C_Organization: 22.2,        // 組織性
          C_Diligence: 23.4,           // 勤勉さ
          C_Perfectionism: 26.7,       // 完璧主義
          C_Prudence: 23.0,            // 慎重さ
          // 開放性のファセット
          O_AestheticAppreciation: 25.8,  // 審美的感受性
          O_Inquisitiveness: 24.7,        // 探究心
          O_Creativity: 21.2,             // 創造性
          O_Unconventionality: 29.1       // 非慣習性
        }
      },
      male: {
        domain: { H: 101.9, E: 105.8, X: 99.0,  A: 90.3,  C: 95.3,  O: 101.7 },
        facet: {
          H_Sincerity: 21.7, H_Fairness: 27.8, H_GreedAvoidance: 24.7, H_Modesty: 27.8,
          E_Fearfulness: 25.5, E_Anxiety: 27.9, E_Dependence: 25.7, E_Sentimentality: 26.7,
          X_Expressiveness: 25.3, X_SocialBoldness: 20.8, X_Sociability: 28.0, X_Liveliness: 25.0,
          A_Forgiveness: 19.7, A_Gentleness: 23.2, A_Flexibility: 24.5, A_Patience: 22.9,
          C_Organization: 22.4, C_Diligence: 23.4, C_Perfectionism: 26.5, C_Prudence: 23.0,
          O_AestheticAppreciation: 24.4, O_Inquisitiveness: 25.9, O_Creativity: 21.3, O_Unconventionality: 29.5
        }
      },
      female: {
        domain: { H: 112.0, E: 114.7, X: 102.7, A: 92.8,  C: 95.1,  O: 100.4 },
        facet: {
          H_Sincerity: 23.1, H_Fairness: 31.9, H_GreedAvoidance: 27.1, H_Modesty: 29.7,
          E_Fearfulness: 27.2, E_Anxiety: 29.3, E_Dependence: 28.4, E_Sentimentality: 29.8,
          X_Expressiveness: 27.0, X_SocialBoldness: 20.8, X_Sociability: 28.7, X_Liveliness: 26.2,
          A_Forgiveness: 20.3, A_Gentleness: 23.6, A_Flexibility: 25.5, A_Patience: 23.4,
          C_Organization: 22.0, C_Diligence: 23.3, C_Perfectionism: 26.9, C_Prudence: 22.9,
          O_AestheticAppreciation: 27.4, O_Inquisitiveness: 23.4, O_Creativity: 21.0, O_Unconventionality: 28.6
        }
      }
    };

    // ==========================================
    // 日本語ラベルの定義
    // ==========================================
    
    // 各ドメイン（因子）の日本語名
    const domainLabelsJA = { 
      H:'誠実‐謙虚性',  // Honesty-Humility
      E:'情動性',        // Emotionality
      X:'外向性',        // eXtraversion
      A:'協調性',        // Agreeableness
      C:'勤勉性',        // Conscientiousness
      O:'開放性'         // Openness to experience
    };

    // ファセット（下位尺度）の並び順と日本語ラベル
    // レーダーチャートとノーム参照で使用
    const facetOrder = [
      // 誠実-謙虚性（H）の4ファセット
      { key:'H_Sincerity', label:'率直さ（誠実さ）', dom:'H' },
      { key:'H_Fairness', label:'公正さ', dom:'H' },
      { key:'H_GreedAvoidance', label:'強欲回避', dom:'H' },
      { key:'H_Modesty', label:'謙虚さ', dom:'H' },

      // 情動性（E）の4ファセット
      { key:'E_Fearfulness', label:'恐れやすさ', dom:'E' },
      { key:'E_Anxiety', label:'不安傾向', dom:'E' },
      { key:'E_Dependence', label:'依存傾向', dom:'E' },
      { key:'E_Sentimentality', label:'感傷性', dom:'E' },

      // 外向性（X）の4ファセット
      { key:'X_Expressiveness', label:'表出性', dom:'X' },
      { key:'X_SocialBoldness', label:'社会的大胆さ', dom:'X' },
      { key:'X_Sociability', label:'社交性', dom:'X' },
      { key:'X_Liveliness', label:'活発さ', dom:'X' },

      // 協調性（A）の4ファセット
      { key:'A_Forgiveness', label:'赦しやすさ', dom:'A' },
      { key:'A_Gentleness', label:'温和さ', dom:'A' },
      { key:'A_Flexibility', label:'柔軟さ', dom:'A' },
      { key:'A_Patience', label:'我慢強さ', dom:'A' },

      // 勤勉性（C）の4ファセット
      { key:'C_Organization', label:'組織性', dom:'C' },
      { key:'C_Diligence', label:'勤勉さ', dom:'C' },
      { key:'C_Perfectionism', label:'完璧主義', dom:'C' },
      { key:'C_Prudence', label:'慎重さ', dom:'C' },

      // 開放性（O）の4ファセット
      { key:'O_AestheticAppreciation', label:'審美的感受性', dom:'O' },
      { key:'O_Inquisitiveness', label:'探究心', dom:'O' },
      { key:'O_Creativity', label:'創造性', dom:'O' },
      { key:'O_Unconventionality', label:'非慣習性', dom:'O' }
    ];

    // ==========================================
    // HEXACO-60 質問項目（全60項目）
    // ==========================================
    // 各項目は5件法（1=全く当てはまらない 〜 5=とても当てはまる）で回答
    const itemTexts_ja = [
      "美術館に行くと，とても退屈してしまう。",
      "最後になってあわてないために，前もって計画を立てて物事の準備をする。",
      "たとえひどく不当な扱いをされた相手に対しても，めったに悪意を抱くことはない。",
      "私は全体的に自分自身にほどよく満足していると感じている。",
      "悪天候のときに旅行をしなければならないとしたら，恐れを感じる。",
      "たとえそうすればうまくいくと思っても，仕事の上で昇進するためにお世辞を言ったりしようとは思わない。",
      "他の国の歴史や政治について学ぶことに興味がある。",
      "目標を達成しようとするときは，しばしば自分をとても激しく追い詰める。",
      "人からときどき，他人に対して批判的すぎると言われる。",
      "集団での話し合いでは，自分の意見を言うことはめったにない。",
      "ちょっとしたことが心配になって，それを抑えることができないことがある。",
      "もし決して捕まらないとわかっているのなら，私は1億円を盗もうと思う。",
      "小説を書いたり，曲を作ったり，絵を描いたりといった，芸術作品を創作することは楽しい。",
      "何かの仕事をするとき，細かい点にはあまり注意を払わない。",
      "ときどき人から，私は頑固すぎると言われる。",
      "一人でやるよりも，積極的な人との関わりを含む仕事の方が好きだ。",
      "苦しい体験に苦しんでいるときには，慰めを与えてくれる人が必要である。",
      "大金を持つことは，自分にとって特に重要なことではない。",
      "とても斬新で慣習にとらわれない考えを考慮することは，<br>時間の無駄だと思う。",
      "私は，よく考えた上でよりも，<br>そのときの気持ち次第で物事を決めることがある。",
      "他の人は，私のことを短気な人間だと思っている。",
      "たいていは，元気で楽天的である。",
      "他の人が泣いているのをみると，私も泣きたくなる。",
      "私は，平均的な人間よりも，優遇される権利があると思う。",
      "もし機会があれば，クラシック音楽の演奏会に行きたい。",
      "仕事をしているとき，ときどき自分がだらしがないために困ってしまうことがある。",
      "私にひどいことをした人に対する私の態度は，「許して忘れる」ことである。",
      "自分は人気がない人間だと感じている。",
      "身体的な危険が迫ると，とても怖い。",
      "もし，何かをある人から手に入れようと思っているときには，その人がくだらない冗談を言っても笑うだろう。",
      "百科事典を読むことを楽しんだことはない。",
      "必要とされる最低限の仕事しかしない。",
      "他の人を判断するときには，甘い（手加減する）傾向がある。",
      "社会的（対人）場面では，たいてい私がはじめに行動する人間である。",
      "他の人ほどは心配性ではない。",
      "たとえどんなに大金でも，賄賂は決して受け取らない。",
      "人から，よく私は優れた想像力を持っていると言われることがある。",
      "たとえ時間がかかっても，自分の仕事ではいつも正確であるようにしている。",
      "人が私に同調しないときは，<br>私はたいてい自分の意見について，かなり柔軟である。",
      "新しい場所に行っていつも最初にすることは，友達を作ることである。",
      "誰かの感情的な支えがないとしても，困難な状況に対処することができる。",
      "高価で贅沢なものを所有することで，多くの楽しみが得られる。",
      "私は，型にはまらない見方をする人が好きである。",
      "行動する前に考えないので，たくさんの失敗をしてしまう。",
      "たいていの人は，私よりもすぐに怒り出す。",
      "たいていの人は，私よりも陽気で活発である。",
      "自分と親しい人が長い間遠くに行ってしまうときには，強い感情を感じる。",
      "私が高い地位にいる重要な人物であることを他の人に知ってほしい。",
      "自分のことを，芸術家タイプとか，創造的なタイプであるとは思わない。",
      "人からしばしば完全主義者だと言われる。",
      "たとえ人がたくさん間違いを犯したときでも，<br>私はめったに否定的なことは言わない。",
      "時々自分は価値のない人間だと感じる。",
      "たとえ非常（緊急）の場合でも，あわてふためいたりすることはない。",
      "誰かに私のたのみを聞いてもらうために，<br>その人を好きなふりをしようとは思わない。",
      "哲学について議論するのは，うんざりである。",
      "私は，何でも計画通りにするよりも，思いついたことをするのが好きである。",
      "人から私が間違っていると言われたとき，<br>私の最初の反応は，相手に同意しないことである。",
      "集団の中にいるとき，しばしばその集団を代表して話をする人間である。",
      "たいていの人がとても感傷的になるような状況でも，私は冷静でいられる。",
      "もし絶対に捕まらないなら，偽札を使ってみたい。"
    ];

    const itemTexts = itemTexts_ja;

    // ==========================================
    // Likert尺度のラベル（5件法）
    // ==========================================
    const likertLabelsJA = [
      '全く<br>当てはまらない',      // 1点
      'あまり<br>当てはまらない',    // 2点
      'どちらとも<br>言えない',      // 3点
      'やや<br>当てはまる',          // 4点
      'とても<br>当てはまる'         // 5点
    ];

    // ==========================================
    // 逆転項目の定義
    // ==========================================
    // これらの項目は得点を反転させる必要がある（6 - 元の得点）
    // 例：「美術館に行くと退屈」→低い得点ほど開放性が高い
    const reverseItems = new Set([
      1,9,10,12,13,15,19,20,21,24,25,28,30,35,38,41,42,44,46,48,50,52,53,55,56,57,59,60
    ]);

    // ==========================================
    // ドメイン（6因子）と項目番号のマッピング
    // ==========================================
    // 各ドメインは10項目で構成される
    const domainMap = {
      'H': [6,12,18,24,30,36,42,48,54,60],  // 誠実-謙虚性
      'E': [5,11,17,23,29,35,41,47,53,59],  // 情動性
      'X': [4,10,16,22,28,34,40,46,52,58],  // 外向性
      'A': [3,9,15,21,27,33,39,45,51,57],   // 協調性
      'C': [2,8,14,20,26,32,38,44,50,56],   // 勤勉性
      'O': [1,7,13,19,25,31,37,43,49,55]    // 開放性
    };

    // ==========================================
    // ファセット（24下位尺度）と項目番号のマッピング
    // ==========================================
    // 各ドメインは4つのファセットに分かれ、各ファセットは2〜4項目
    const facetMap = {
      'H': {
        '率直さ（誠実さ）': [6,30,54],
        '公正さ': [12,36,60],
        '強欲回避': [18,42],
        '謙虚さ': [24,48]
      },
      'E': {
        '恐れやすさ': [5,29,53],
        '不安傾向': [11,35],
        '依存傾向': [17,41],
        '感傷性': [23,47,59]
      },
      'X': {
        '表出性': [4,28,52],
        '社会的大胆さ': [10,34,58],
        '社交性': [16,40],
        '活発さ': [22,46]
      },
      'A': {
        '赦しやすさ': [3,27],
        '温和さ': [9,33,51],
        '柔軟さ': [15,39,57],
        '我慢強さ': [21,45]
      },
      'C': {
        '組織性': [2,32,50],
        '勤勉さ': [8,26,56],
        '完璧主義': [14,38],
        '慎重さ': [20,44]
      },
      'O': {
        '審美的感受性': [1,25,49,55],
        '探究心': [7,31],
        '創造性': [13,37],
        '非慣習性': [19,43]
      }
    };

    // ==========================================
    // 自己診断テスト（開発用）
    // ==========================================
    // 得点計算が正しく動作するか確認するためのテスト
    (function selfTests(){
      try {
        console.group('%cHEXACO-60 self-tests','color:#0a0');
        
        // 項目数が60であることを確認
        console.assert(itemTexts.length === 60, `Items length must be 60, got ${itemTexts.length}`);
        
        // 各ドメインが10項目であることを確認
        for (const [dom, arr] of Object.entries(domainMap)) {
          console.assert(arr.length === 10, `Domain ${dom} must have 10 items`);
        }
        
        // ドメインマップが60項目すべてをカバーしていることを確認
        const allItems = Object.values(domainMap).flat();
        console.assert(new Set(allItems).size === 60, 'Domain map covers 60 unique items');
        
        // ノームデータにすべてのファセットが含まれていることを確認
        console.assert(
          facetOrder.every(f=>norms.total.facet.hasOwnProperty(f.key)), 
          'norms.total.facet has all keys in facetOrder'
        );
        
        // ファセットマップにすべてのファセットラベルが含まれていることを確認
        console.assert(
          facetOrder.every(f=>facetMap[f.dom] && Object.keys(facetMap[f.dom]).includes(f.label)), 
          'facetMap contains all facet labels in facetOrder'
        );
        
        // 全項目に3点を回答した場合、各ドメインの合計が30になることを確認
        const all3 = Array(60).fill(3);
        const s3 = computeScores(all3);
        Object.entries(s3.domains).forEach(([k,v])=>
          console.assert(v.sum===30, `All-3s ${dom} sum should be 30, got ${v.sum}`)
        );
        
        // 全項目に1点を回答した場合、逆転項目を考慮した合計が正しいことを確認
        const all1 = Array(60).fill(1);
        const r1 = computeScores(all1);
        for (const [dom, nums] of Object.entries(domainMap)){
          const revCnt = nums.filter(n=>reverseItems.has(n)).length;
          const expected = (nums.length - revCnt)*1 + revCnt*5;
          console.assert(
            r1.domains[dom].sum === expected, 
            `All-1s ${dom} expected ${expected}, got ${r1.domains[dom].sum}`
          );
        }
        
        // ファセットレベルでも同様の確認
        for (const [dom, fobj] of Object.entries(facetMap)){
          for (const [fname, nums] of Object.entries(fobj)){
            const revCnt = nums.filter(n=>reverseItems.has(n)).length;
            const expected = (nums.length - revCnt)*1 + revCnt*5;
            console.assert(
              r1.facets[dom][fname].sum === expected, 
              `All-1s ${dom}/${fname} expected ${expected}, got ${r1.facets[dom][fname].sum}`
            );
          }
        }
        
        console.groupEnd();
      } catch(e){
        console.error('Self-test error', e);
      }
    })();

    // ==========================================
    // システム情報取得関数
    // ==========================================
    /**
     * ブラウザとOSの情報を取得する関数
     * @returns {Object} { browser: ブラウザ名, os: OS名, user_agent: 完全なユーザーエージェント文字列 }
     * 
     * navigator.userAgent から情報を抽出
     */
    function getSystemInfo() {
      const ua = navigator.userAgent;
      let browser = 'Unknown';
      let os = 'Unknown';

      // ブラウザの判定
      if (ua.indexOf('Edg') > -1) browser = 'Edge';
      else if (ua.indexOf('Chrome') > -1) browser = 'Chrome';
      else if (ua.indexOf('Safari') > -1) browser = 'Safari';
      else if (ua.indexOf('Firefox') > -1) browser = 'Firefox';
      else if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) browser = 'IE';

      // OSの判定
      if (ua.indexOf('Win') > -1) os = 'Windows';
      else if (ua.indexOf('Mac') > -1) os = 'macOS';
      else if (ua.indexOf('Linux') > -1) os = 'Linux';
      else if (ua.indexOf('Android') > -1) os = 'Android';
      else if (ua.indexOf('iOS') > -1 || ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) os = 'iOS';

      return { browser, os, user_agent: ua };
    }

    /**
     * 日本時間（JST）で現在時刻を取得する関数
     * @returns {string} YYYY/MM/DD HH:MM:SS 形式の日本時間文字列
     * 
     * タイムゾーンを 'Asia/Tokyo' に指定してフォーマット
     */
    function getJapanTime() {
      return new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
    }

    // ==========================================
    // ユーティリティ関数
    // ==========================================
    
    /**
     * 配列を指定されたサイズに分割する関数
     * @param {Array} arr - 分割する配列
     * @param {number} size - 各チャンクのサイズ
     * @returns {Array[]} 分割された配列の配列
     * 
     * 例: chunk([1,2,3,4,5], 2) → [[1,2], [3,4], [5]]
     * 60項目を10項目ずつ6ページに分割する際に使用
     */
    const chunk = (arr, size) => arr.reduce((acc, _, i) => (i % size ? acc : [...acc, arr.slice(i, i + size)]), []);
    
    /**
     * 逆転項目の得点を変換する関数
     * @param {number} raw - 元の回答値（1-5の5件法）
     * @returns {number} 変換後の得点（逆転項目の場合は6-raw）
     * 
     * 注：この関数は単純な反転のみ。実際の判定はcomputeScores内で行う
     * 例: raw=1 → 6-1=5, raw=5 → 6-5=1
     */
    const reverseScore = (raw) => 6 - raw;
    
    /**
     * 進捗バーを更新する関数
     * @param {number} fraction - 進捗率（0.0〜1.0）
     * 
     * jsPsychの進捗バーの幅をパーセンテージで更新
     * 例: fraction=0.5 → 50%
     */
    const updateProgressBar = (fraction) => {
      const barInner = document.querySelector('#jspsych-progressbar-inner');
      if (barInner) {
        const clamped = Math.max(0, Math.min(1, fraction));
        barInner.style.width = `${Math.round(clamped * 100)}%`;
      }
    };

    // ==========================================
    // 得点計算関数
    // ==========================================
    /**
     * HEXACO-60の得点を計算する関数
     * @param {number[]} responses - 60項目の回答（1-5の値の配列）
     * @returns {Object} ドメインとファセットの得点情報
     * 
     * 処理の流れ：
     * 1. 各項目について逆転項目かどうかを判定
     * 2. 逆転項目の場合は6から引いた値を使用（6-回答値）
     * 3. 各ドメイン（6因子）ごとに10項目の合計を計算
     * 4. 各ファセット（24下位尺度）ごとに該当項目の合計を計算
     */
    function computeScores(responses) {
      // 指定された項目番号（1-60）の回答値を取得
      const get = (n) => responses[n-1];
      
      // 逆転項目の場合は6-回答値、通常項目はそのまま
      // 例：項目1（逆転項目）で回答が1の場合 → 6-1=5
      const scoreOf = (n) => reverseItems.has(n) ? (6 - get(n)) : get(n);

      // ==========================================
      // ドメイン（6因子）レベルの得点計算
      // ==========================================
      const domains = {};
      for (const [dom, nums] of Object.entries(domainMap)) {
        // 各ドメインに属する10項目の得点を取得（逆転処理済み）
        const vals = nums.map(scoreOf);
        // 10項目の合計を計算（最小10点〜最大50点）
        const sum = vals.reduce((a,b)=>a+b,0);
        domains[dom] = { sum, items: nums };
      }

      // ==========================================
      // ファセット（24下位尺度）レベルの得点計算
      // ==========================================
      const facets = {};
      for (const [dom, fobj] of Object.entries(facetMap)) {
        facets[dom] = {};
        for (const [facet, nums] of Object.entries(fobj)) {
          // 各ファセットに属する項目の得点を取得（逆転処理済み）
          const vals = nums.map(scoreOf);
          // 該当項目の合計を計算（項目数は2〜4）
          const sum = vals.reduce((a,b)=>a+b,0);
          facets[dom][facet] = { sum, items: nums };
        }
      }
      
      return { domains, facets };
    }

    // ==========================================
    // jsPsych実験の初期化
    // ==========================================
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',     // 実験を表示するHTML要素のID
      show_progress_bar: true,                // 進捗バーを表示
      auto_update_progress_bar: false        // 進捗バーは手動更新（各ページで明示的に更新）
    });

    // ==========================================
    // 参加者ID・ファイル名の生成
    // ==========================================
    // OSFへのデータ保存用に一意なIDとファイル名を生成
    const subject_id = jsPsych.randomization.randomID(10);  // 10文字のランダムID
    const filename   = `${subject_id}.csv`;                  // CSV形式で保存
    
    // すべてのトライアルに追加されるメタデータ
    jsPsych.data.addProperties({
      subject_id,
      timestamp_start: new Date().toISOString()  // 実験開始時刻（ISO形式）
    });

    // ==========================================
    // 進捗バーのラベルを日本語化
    // ==========================================
    // デフォルトの "Completion Progress" を「進捗状況」に変更
    (function setProgressLabel(){
      const setLabel = () => {
        const span = document.querySelector('#jspsych-progressbar-container span');
        if (span) {
          span.innerHTML = '進捗状況';
          return true;
        }
        return false;
      };
      // 進捗バーがまだ生成されていない場合は、DOMの変化を監視
      if (!setLabel()) {
        const mo = new MutationObserver((_, obs) => {
          if (setLabel()) obs.disconnect();
        });
        mo.observe(document.body, { childList: true, subtree: true });
      }
    })();

    // ==========================================
    // 実験タイムラインの構築
    // ==========================================
    const timeline = [];

    // ------------------------------------------
    // 1. ウェルカムページ
    // ------------------------------------------
    // 実験の説明と倫理的配慮を表示
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="grid">
          <div class="card">
            <h2>HEXACO-60</h2>
            <h3>「感情・人格心理学」受講者用</h3>
            <p class="note">  
              これはHEXACOパーソナリティモデルを評価する
              60 項目のアンケートであり，講義内容の理解を促進するために利用されます。<br   >データは保管されますが，個人が特定されることはなく，回答の有無が成績に影響することは一切ありません。<br><br>
              次のページから並んでいる項目の内容について，自分にどの程度あてはまっているか，あてはまっていないかを考えて，各文の下の選択肢から一つを選んでください。なお，<strong>「どちらでもない」はできるだけ選択しないようにしてください。</strong>（どうしてもどちらとも決められない場合にのみ選択してください）<br>
            </p>
            <ul class="small muted">
              回答時間の目安：10〜15分 <br>
              すべての項目に回答してください（未回答不可）<br><br>
              出典<br>Wakabayashi, A. (2014). A sixth personality domain that is independent of the Big Five domains: The psychometric properties of the HEXACO Personality Inventory in a Japanese sample. Japanese Psychological Research, 56(3), 211–223. https://doi.org/10.1111/jpr.12045
            </ul>
          </div>
        </div>
      `,
      choices: ['はじめる']
    });

    // ------------------------------------------
    // 2. 属性情報の収集（年齢・性別）
    // ------------------------------------------
    // 性別は日本人ノームの選択に使用される
    timeline.push({
      type: jsPsychSurvey,
      survey_json: {
        showQuestionNumbers: false,  // 質問番号を非表示
        pages: [{
          name: 'demographics',
          elements: [
            { 
              type: 'text', 
              name: 'age', 
              title: '年齢', 
              inputType: 'number', 
              min: 0, 
              max: 120, 
              isRequired: true 
            },
            { 
              type: 'dropdown', 
              name: 'gender', 
              title: '性別', 
              isRequired: true, 
              choices: ['男性','女性','その他','未回答'] 
            }
          ]
        }],
        pageNextText: '次へ', 
        pagePrevText: '戻る', 
        completeText: '次へ'
      },
      on_finish: (data) => {
        // 回答データをjsPsychのグローバルデータに追加
        const r = data.response || {};
        jsPsych.data.addProperties({ 
          age: r.age || '', 
          gender: r.gender || '' 
        });
      }
    });

    // ------------------------------------------
    // 3. HEXACO-60 質問項目（10問×6ページ）
    // ------------------------------------------
    const totalItems = itemTexts.length;  // 60項目
    const perPage = 10;                    // 1ページあたり10項目
    const pages = chunk(itemTexts, perPage);  // 6ページに分割
    
    // システム情報とタイムスタンプを取得
    const sysInfo = getSystemInfo();
    const startTime = getJapanTime();
    const startTimestamp = Date.now();

    pages.forEach((pageItems, pageIdx) => {
      const start = pageIdx * perPage + 1;  // このページの最初の項目番号
      const end = Math.min(totalItems, (pageIdx + 1) * perPage);  // このページの最後の項目番号
      const isLastPage = pageIdx === pages.length - 1;  // 最終ページかどうか

      timeline.push({
        type: jsPsychSurveyLikert,
        preamble: `<div class="card"><b>質問 ${start}–${end} / ${totalItems}</b><div class="small muted">各項目に対して最も近い選択肢を選んでください。</div></div>`,
        randomize_question_order: false,  // 項目順をランダム化しない
        button_label: isLastPage ? '結果を見る' : '次へ',  // 最終ページのみボタンラベルを変更
        questions: pageItems.map((txt, i) => ({
          prompt: `<div class="note">${txt}</div>`,  // 質問文
          labels: likertLabelsJA,  // 5件法のラベル
          required: true,  // 必須回答
          name: `Q${start + i}`  // 質問名（Q1〜Q60）
        })),
        on_finish: (data) => {
          // ==========================================
          // 各回答に詳細なメタデータを追加
          // ==========================================
          const resp = data.response || {};
          
          // このページで回答された項目番号のリスト
          const itemsOnPage = [];
          for (let i = start; i <= end; i++) {
            itemsOnPage.push(i);
          }
          
          // 各項目について、raw（素点）、scored（換算後）、reversed（逆転フラグ）を記録
          Object.entries(resp).forEach(([qName, idx]) => {
            const itemNum = parseInt(qName.replace('Q', ''), 10);  // Q1 → 1
            const raw = Number(idx) + 1;  // 0-4 → 1-5
            const isReversed = reverseItems.has(itemNum);
            const scored = isReversed ? (6 - raw) : raw;
            
            // CSVに記録される変数名
            data[`${qName}_raw`] = raw;           // 素点（1-5）
            data[`${qName}_scored`] = scored;     // 換算後の得点（逆転処理済み）
            data[`${qName}_reversed`] = isReversed ? 1 : 0;  // 逆転項目フラグ（1=逆転、0=通常）
            data[`${qName}_item_number`] = itemNum;  // 項目番号
          });
          
          // ==========================================
          // システム情報とタイムスタンプの記録
          // ==========================================
          data.browser = sysInfo.browser;
          data.os = sysInfo.os;
          data.user_agent = sysInfo.user_agent;
          data.start_time_jst = startTime;
          data.start_timestamp = startTimestamp;
          data.end_time_jst = getJapanTime();
          data.end_timestamp = Date.now();
          
          // 所要時間の計算
          const duration_ms = data.end_timestamp - startTimestamp;
          data.total_duration_ms = duration_ms;
          data.total_duration_sec = (duration_ms / 1000).toFixed(2);
          data.total_duration_min = (duration_ms / 60000).toFixed(2);
          
          // ページ情報
          data.page_number = pageIdx + 1;
          data.page_items = itemsOnPage.join(',');
          
          // 進捗バーを更新（現在の完了項目数 / 全項目数）
          updateProgressBar(end / totalItems);
          
          // 最終ページ以外はページトップにスクロール
          if (!isLastPage) {
            window.scrollTo(0, 0);
          }
        }
      });
    });

    // ------------------------------------------
    // 4. データ保存（OSFへアップロード）
    // ------------------------------------------
    // CSV出力を心理統計に適した形式に変換する関数
    function generateAnalysisReadyCSV() {
      // すべてのトライアルを取得
      const allTrials = jsPsych.data.get().values();
      
      // メタデータを取得
      const subject_id = allTrials[0]?.subject_id || '';
      const age = allTrials[0]?.age || '';
      const gender = allTrials[0]?.gender || '';
      const browser = allTrials[0]?.browser || '';
      const os = allTrials[0]?.os || '';
      const timestamp_start = allTrials[0]?.timestamp_start || '';
      const timestamp_end = allTrials[allTrials.length - 1]?.timestamp_end || '';
      
      // Likert回答データの詳細情報を取得
      const likertTrials = allTrials.filter(t => t.trial_type === 'survey-likert');
      
      // 各項目の情報を保存する連想配列
      const itemData = {};
      for (let i = 1; i <= 60; i++) {
        itemData[i] = {
          response: null,      // 1-5の回答値
          page: null,          // 回答ページ（1-6）
          rt: null,            // 反応時間（ms）
          reversed: reverseItems.has(i) ? 1 : 0  // 逆転項目フラグ
        };
      }
      
      // Likertトライアルから情報を抽出
      likertTrials.forEach(tr => {
        const resp = tr.response || {};
        const page = tr.page_number || null;
        const rt = tr.rt || null;
        
        Object.entries(resp).forEach(([name, idx]) => {
          const n = parseInt(name.replace('Q',''), 10);
          if (itemData[n]) {
            itemData[n].response = Number(idx) + 1;  // 0-4 → 1-5
            itemData[n].page = page;
            itemData[n].rt = rt;
          }
        });
      });
      
      // ==========================================
      // CSV用のデータオブジェクト（ワイド形式）
      // ==========================================
      // 列の順序：メタデータ → Q1, Q1_page, Q1_rt, Q1_reversed, Q2, ...
      const rowData = {
        subject_id,
        age,
        gender,
        browser,
        os,
        timestamp_start,
        timestamp_end,
        total_items: 60,
        survey_complete: Object.values(itemData).every(d => d.response !== null) ? 1 : 0
      };
      
      // 60個の質問について、詳細情報を追加
      for (let i = 1; i <= 60; i++) {
        const data = itemData[i];
        rowData[`Q${i}`] = data.response !== null ? data.response : '';
        rowData[`Q${i}_page`] = data.page !== null ? data.page : '';
        rowData[`Q${i}_rt`] = data.rt !== null ? Math.round(data.rt) : '';
        rowData[`Q${i}_reversed`] = data.reversed;
      }
      
      // ==========================================
      // CSV形式で出力（CSVエスケープ処理）
      // ==========================================
      const headers = Object.keys(rowData);
      const headerLine = headers.map(h => `"${h}"`).join(',');
      
      // データ行を生成
      const values = headers.map(h => {
        const v = rowData[h];
        if (v === null || v === '') return '';
        const s = String(v);
        // ダブルクォート、カンマ、改行を含む場合はエスケープ
        if (s.includes('"') || s.includes(',') || s.includes('\n')) {
          return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
      });
      const dataLine = values.join(',');
      
      return headerLine + '\n' + dataLine;
    }
    
    // jsPsych Pipeプラグインを使用してOSFにCSVデータを保存
    // 【修正】SD3j と BFI-2-S-J に合わせてシンプル化
    const save_data = {
      type: window.jsPsychPipe,
      action: 'save',  // 保存アクション
      experiment_id: 'TY0B485foupj',  // OSFのExperiment ID
      filename: filename,  // 保存するファイル名（subject_id.csv）
      wait_message: `
        <div class="card">
          <h3>結果をまとめています...</h3>
          <p class="small muted">数秒お待ちください。</p>
        </div>
      `,
      // 【修正】SD3j と同じく、jsPsychの全データを直接CSV形式で取得
      data_string: () => jsPsych.data.get().csv(),
      on_start: () => {
        // 実験終了時刻を記録
        jsPsych.data.addProperties({ timestamp_end: new Date().toISOString() });
        console.log('[HEXACO-60] Saving data via jsPsych Pipe:', { filename, experiment_id: 'TY0B485foupj' });
        updateProgressBar(1);  // 進捗バーを100%に
      },
      on_finish: (data) => {
        // 保存結果を確認
        const result = data?.result || {};
        if (data?.success && !result.error) {
          console.log('[HEXACO-60] Data saved to OSF successfully:', result);
        } else {
          console.warn('[HEXACO-60] OSF save reported error:', result.error);
        }
        // 保存結果をグローバル変数に保存（結果画面で参照）
        window.__pipe_result = {
          success: data?.success === true && !result.error,
          error: result.error || null,
          url: result.url || ''
        };
      }
    };
    
    // タイムラインにデータ保存トライアルを追加
    timeline.push(save_data);

    // ------------------------------------------
    // 5. 結果表示（レーダーチャート）
    // ------------------------------------------
    // 保存の成否に関わらず、結果画面を表示
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        updateProgressBar(1);  // 進捗バーを100%に
        
        // ==========================================
        // 回答データの取得と変換
        // ==========================================
        // jsPsychに保存されたLikert回答を取り出す
        // 注：Likertプラグインは0-4で保存するため、+1して1-5に変換
        const trials = jsPsych.data.get().filter({ trial_type: 'survey-likert' }).values();
        const responses = new Array(60).fill(null);
        trials.forEach(tr => {
          const resp = tr.response || {};
          Object.entries(resp).forEach(([name, idx]) => {
            const n = parseInt(name.replace('Q',''), 10);
            responses[n-1] = Number(idx) + 1;  // 0-4 → 1-5
          });
        });

        // 未回答項目がある場合はエラーメッセージを表示
        if (responses.some(v => v === null)) {
          return `<div class=\"card\"><p>未回答の項目があります。<b>すべての項目</b>に回答してください。</p></div>`;
        }

        // ==========================================
        // 得点計算（ドメインとファセット）
        // ==========================================
        const scored = computeScores(responses);
        
        // ドメインの得点を表形式で整形
        const domRows = Object.entries(scored.domains).map(([dom, v]) => `
          <tr><td>${domainLabelsJA[dom]} (${dom})</td><td style=\"text-align:right\">${v.sum}</td></tr>
        `).join('');

        // ==========================================
        // データ保存ステータスの確認
        // ==========================================
        let saveNote = '';
        try {
          const pr = window.__pipe_result;
          if (pr && pr.success === true) {
            saveNote = `<div class="small muted">✓ 計算が完了しました。</div>`;
          } else if (pr && pr.success === false) {
            saveNote = `<div class="small danger">⚠ データ保存に失敗しました（${pr.error || 'unknown error'}）。ただしブラウザに結果が表示されています。</div>`;
          } else {
            saveNote = `<div class="small danger">⚠ データ保存の状態を確認できません。ブラウザに結果が表示されています。</div>`;
          }
        } catch(e) {
          console.error('[HEXACO-60] Error reading pipe result:', e);
          saveNote = `<div class="small danger">⚠ データ保存の状態を確認できませんでした。</div>`;
        }

        // ==========================================
        // 結果画面のHTML生成
        // ==========================================
        return `
          <div class="card">
            <h3>回答ありがとうございました。</h3>
            ${saveNote}
            <p>6 因子の<strong>合計スコア</strong>（各因子10項目・1〜5点×10＝最大50点）</p>
            <table style="width:100%">
              <thead><tr><th style="text-align:left">因子</th><th style="text-align:right">合計</th></tr></thead>
              <tbody>${domRows}</tbody>
            </table>

            <h4 style="margin-top:1rem">レーダーチャート（因子：自分 vs 日本人平均）</h4>
            <div class="chart-wrap domain"><canvas id="hexaco-radar-domain"></canvas></div>

            <h4 style="margin-top:1rem">レーダーチャート（ファセット：自分 vs 日本人基準）</h4>
            <div class="chart-wrap facet"><canvas id="hexaco-radar-facet"></canvas></div>

            <details id=\"debug-block\" class=\"small\" style=\"margin-top:1rem\">
              <summary>採点内訳を表示（ドメイン/ファセット・逆転処理後）</summary>
              <div id=\"debug-content\"></div>
            </details>

            <div class="footer muted" style="margin-top:1rem">
              <div>備考：平均は HEXACO-60（2~4項目/ファセット, 10項目/ドメイン）の<strong>合計得点の平均値（Table 1 の M）</strong>を用いています。<br>参加者のスコアは HEXACO-60 の<strong>合計得点</strong>（ドメイン=10項目合計、ファセット=該当項目合計）です。<br>※ 尺度の項目数が異なるため絶対値は一致しません。</div>
              <div>参考：Wakabayashi, A. (2014). A sixth personality domain that is independent of the Big Five domains: The psychometric properties of the HEXACO Personality Inventory in a Japanese sample. Japanese Psychological Research, 56(3), 211–223. https://doi.org/10.1111/jpr.12045</div>
            </div>
          </div>
        `;
      },
      choices: ['終了'],
      on_load: () => {
        // ページ読み込み後、少し下にスクロールして結果を見やすくする
        setTimeout(() => {
          window.scrollBy({ top: 300, behavior: 'smooth' });
        }, 150);
        
        // ==========================================
        // 回答データの再取得
        // ==========================================
        const trials = jsPsych.data.get().filter({ trial_type: 'survey-likert' }).values();
        const responses = new Array(60).fill(null);
        trials.forEach(tr => {
          const resp = tr.response || {};
          Object.entries(resp).forEach(([name, idx]) => {
            const n = parseInt(name.replace('Q',''), 10);
            responses[n-1] = Number(idx) + 1;  // 0-4 → 1-5
          });
        });
        if (responses.some(v => v === null)) return;  // 未回答があれば処理を中断

        // ==========================================
        // 性別に応じた日本人ノームの選択
        // ==========================================
        const meta = jsPsych.data.get().values().find(v => v.gender !== undefined) || {};
        const g = (meta.gender || '').trim();
        let normSet = norms.total; 
        let normLabel = '日本人平均（全体）';
        if (g === '男性') { 
          normSet = norms.male; 
          normLabel = '日本人平均（男性）'; 
        } else if (g === '女性') { 
          normSet = norms.female; 
          normLabel = '日本人平均（女性）'; 
        }

        // 得点計算
        const { domains, facets } = computeScores(responses);

        // ==========================================
        // チャートの配色設定（ダークモード対応）
        // ==========================================
        const isDark = document.body.classList.contains('dark');
        const txtColor = isDark ? '#ffffff' : '#000000';
        const gridColor = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.2)';

        // ==========================================
        // ドメインレーダーチャート（6因子）
        // ==========================================
        const order = ['H','E','X','A','C','O'];
        const labelsDom = order.map(k => `${domainLabelsJA[k]} (${k})`);
        const selfDom = order.map(k => domains[k].sum);
        const normDom = order.map(k => normSet.domain[k]);
        const ctxD = document.getElementById('hexaco-radar-domain');
        
        // 配色パレット（ダークモードでは明るい色を使用）
        const palette = isDark
          ? { selfBorder:'#4FC3F7', selfFill:'rgba(79,195,247,0.18)', normBorder:'#FFB74D', normFill:'rgba(255,183,77,0.18)' }
          : { selfBorder:'#1976D2', selfFill:'rgba(25,118,210,0.15)', normBorder:'#D32F2F', normFill:'rgba(211,47,47,0.15)' };
        
        if (ctxD) new window.Chart(ctxD, {
          type: 'radar',
          data: {
            labels: labelsDom,
            datasets: [
              { 
                label: '自分', 
                data: selfDom, 
                pointRadius: 3, 
                fill: true, 
                borderColor: palette.selfBorder, 
                backgroundColor: palette.selfFill, 
                borderWidth: 2.5, 
                tension: 0 
              },
              { 
                label: `${normLabel}`, 
                data: normDom, 
                pointRadius: 3, 
                fill: true, 
                borderColor: palette.normBorder, 
                backgroundColor: palette.normFill, 
                borderWidth: 2.5, 
                tension: 0 
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { 
              r: { 
                min: 0, 
                max: 160,  // ノームの最大値を考慮
                ticks: { color: txtColor }, 
                pointLabels: { color: txtColor }, 
                grid: { color: gridColor }, 
                angleLines: { color: gridColor } 
              } 
            },
            plugins: { 
              legend: { position: 'bottom', labels: { color: txtColor } }, 
              tooltip: { enabled: true } 
            },
            elements: { line: { borderWidth: 2.5, tension: 0 } }
          }
        });

        // ==========================================
        // ファセットレーダーチャート（24下位尺度）
        // ==========================================
        const labelsFacet = facetOrder.map(f => `${f.label}`);
        const selfFacet = facetOrder.map(f => {
          const domFacets = facets[f.dom];
          const match = Object.entries(domFacets).find(([fname]) => fname === f.label);
          return match ? match[1].sum : 0;
        });
        const normFacet = facetOrder.map(f => normSet.facet[f.key]);
        
        // ==========================================
        // デバッグ用：採点内訳テーブルの生成
        // ==========================================
        try {
          const scoreOf = (n) => reverseItems.has(n) ? (6 - responses[n-1]) : responses[n-1];
          
          // テーブルHTML生成用のヘルパー関数
          const makeTable = (headers, rows) => {
            const ths = headers.map(h=>`<th>${h}</th>`).join('');
            const trs = rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('');
            return `<table style=\"width:100%; font-size:12px\"><thead><tr>${ths}</tr></thead><tbody>${trs}</tbody></table>`;
          };
          
          // ドメインごとの採点内訳
          let domHtml = '';
          const order = ['H','E','X','A','C','O'];
          order.forEach(dom => {
            const items = domainMap[dom];
            const rows = items.map(n=>{
              const raw = responses[n-1];  // 素点（1-5）
              const rev = reverseItems.has(n);  // 逆転項目かどうか
              const sc = scoreOf(n);  // 換算後の得点
              return [n, raw, rev?'<span style=\"color:#b00\">R</span>':'', sc];
            });
            const sum = rows.reduce((a,b)=>a+Number(b[3]),0);
            rows.push(['合計','','',`<b>${sum}</b>`]);
            domHtml += `<h5 style=\"margin-top:8px\">${domainLabelsJA[dom]} (${dom})</h5>${makeTable(['項目','素点','R','換算後'], rows)}`;
          });
          
          // ファセットごとの採点内訳
          let facetHtml = '';
          facetOrder.forEach(f => {
            const nums = (facetMap[f.dom]||{})[f.label]||[];
            const rows = nums.map(n=>{
              const raw = responses[n-1];
              const rev = reverseItems.has(n);
              const sc = scoreOf(n);
              return [n, raw, rev?'<span style=\"color:#b00\">R</span>':'', sc];
            });
            const sum = rows.reduce((a,b)=>a+Number(b[3]||0),0);
            rows.push(['合計','','',`<b>${sum}</b>`]);
            facetHtml += `<h5 style=\"margin-top:8px\">${f.label}</h5>${makeTable(['項目','素点','R','換算後'], rows)}`;
          });
          
          // デバッグ用HTMLを挿入
          const dbg = document.getElementById('debug-content');
          if (dbg) dbg.innerHTML = `<div class=\"radar-wrap\"><h4>ドメイン内訳</h4>${domHtml}<h4 style=\"margin-top:12px\">ファセット内訳</h4>${facetHtml}</div>`;
        } catch(e){ 
          console.warn('debug table render failed', e); 
        }

        // ファセットレーダーチャートの描画
        const ctxF = document.getElementById('hexaco-radar-facet');
        if (ctxF) new window.Chart(ctxF, {
          type: 'radar',
          data: {
            labels: labelsFacet,
            datasets: [
              { 
                label: '自分', 
                data: selfFacet, 
                pointRadius: 2, 
                fill: true, 
                borderColor: palette.selfBorder, 
                backgroundColor: palette.selfFill, 
                borderWidth: 1.8, 
                tension: 0 
              },
              { 
                label: `${normLabel}`, 
                data: normFacet, 
                pointRadius: 2, 
                fill: true, 
                borderColor: palette.normBorder, 
                backgroundColor: palette.normFill, 
                borderWidth: 1.8, 
                tension: 0 
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { 
              r: { 
                min: 0, 
                max: 32,  // ファセットの最大値を考慮
                ticks: { display: false, color: txtColor },  // 数値ラベルは非表示
                pointLabels: { color: txtColor }, 
                grid: { color: gridColor }, 
                angleLines: { color: gridColor } 
              } 
            },
            plugins: { 
              legend: { position: 'bottom', labels: { color: txtColor } }, 
              tooltip: { enabled: true } 
            },
            elements: { line: { borderWidth: 1.8, tension: 0 } }
          }
        });
      },
      on_finish: function() {
        // 実験終了後、トップページに遷移
        window.location.href = 'https://mshrymgc.github.io/epp_scales/';
      }
    });

    // ==========================================
    // 実験の実行
    // ==========================================
    // グローバルスコープに関数を登録（Datapipe用）
    window.generateAnalysisReadyCSV = generateAnalysisReadyCSV;
    window.jsPsych_instance = jsPsych;
    window.timeline_data = timeline;
    
    jsPsych.run(timeline);
  })();
  </script>
</body>
</html>
