<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RRQ 日本語版</title>
  <link rel="stylesheet" href="../dist/jspsych.css" />
  <link rel="stylesheet" href="../dist/survey.min.css" />
  <style>
    /* ==========================================
       基本スタイル
       ========================================== */
    body {
      font-family: system-ui, sans-serif;
    }

    /* カード型のコンテナ */
    .card {
      background: #fff;
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 1rem;
    }

    /* グリッドレイアウト */
    .grid {
      display: grid;
      gap: 1rem;
    }

    /* 結果画面のグリッド */
    .result-grid {
      display: grid;
      gap: 1.2rem;
      margin-top: 1.5rem;
    }

    /* レスポンシブ: 780px以上で2カラム表示 */
    @media (min-width: 780px) {
      .result-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: start;
      }
    }

    /* ==========================================
       グラフ関連
       ========================================== */
    .chart-wrap {
      position: relative;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }

    .chart-small {
      height: 260px;
      max-height: 320px;
    }

    .chart-wrap canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ==========================================
       テーブルスタイル
       ========================================== */
    table {
      border-collapse: collapse;
      width: 100%;
    }

    th,
    td {
      padding: 0.45rem 0.4rem;
      border-bottom: 1px solid #eee;
      text-align: left;
      font-size: 0.95rem;
    }

    th {
      font-weight: 600;
      background: #fafafa;
    }

    /* ==========================================
       ユーティリティクラス
       ========================================== */
    .small {
      font-size: 0.85rem;
    }

    .muted {
      color: #666;
    }

    /* ==========================================
       ツールチップ（ホバー時の説明表示）
       ========================================== */
    .likert-label-tooltip {
      position: relative;
    }

    .likert-label-tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 0.8rem;
      opacity: 0;
      transition: opacity 0.15s ease;
      pointer-events: none;
      z-index: 10;
    }

    .likert-label-tooltip:hover::after {
      opacity: 1;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="../dist/jspsych.js"></script>
  <script src="../dist/plugin-html-button-response.js"></script>
  <script src="../dist/plugin-survey.js"></script>
  <script src="../dist/plugin-survey-likert.js"></script>
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe@0.5.0/dist/index.browser.min.js"></script>
</head>
</head>
<body>
  <div id="jspsych-target"></div>
  <script>
(() => {
  // ==========================================
  // 0. jsPsych の初期化と基本設定
  // ==========================================
  const PROGRESS_LABEL_TEXT = '進捗状況'; // 進捗バーに表示するテキスト
  const PAGE_SIZE = 6; // 1ページに表示する質問数（反芻・省察を6問ずつ）
  const LIKERT_CHOICES = [
    { value: 1, text: '1 = 全く当てはまらない' },
    { value: 2, text: '2 = 当てはまらない' },
    { value: 3, text: '3 = どちらともいえない' },
    { value: 4, text: '4 = 当てはまる' },
    { value: 5, text: '5 = よく当てはまる' }
  ];
  const DEBUG = false; // true にすると処理の流れをコンソールに表示
  const debugLog = (...args) => { if (DEBUG) console.log(...args); };

  const jsPsych = window.jsPsychModule.initJsPsych({
    display_element: 'jspsych-target',
    show_progress_bar: true,
    auto_update_progress_bar: false
  });

  setProgressLabelToJapanese();
  injectResultStyles();

  // ==========================================
  // 1. 尺度項目の定義
  // ==========================================
  const RRQ = {
    rumination: [
      { id: 1, text: '自分のある側面について考えるのをやめたいと思っていても，そこに注意が向くことが多い。', reverse: false },
      { id: 2, text: '最近自分が言ったことやしたことについて，頭の中でいつも思い返しているように思う。', reverse: false },
      { id: 3, text: '時々，自分自身について考えるのをなかなかやめることができない。', reverse: false },
      { id: 4, text: '口論や意見の不一致があると，その後長い間私は起こったことを考えつづける。', reverse: false },
      { id: 5, text: '本当に長い間，自分に起こったことを繰り返し考えたり，つくづくと考えたりしがちだ。', reverse: false },
      { id: 6, text: '終わったことやしてしまったことを思い返すために時間を使うことはない。', reverse: true },
      { id: 7, text: '過去にあった場面で，自分がどう振舞ったかを頭の中でよく思い返している。', reverse: false },
      { id: 8, text: '自分がしたことについて，自らもう一度評価をしていることに気が付くことがよくある。', reverse: false },
      { id: 9, text: 'あまり長い間，自分自身のことを繰り返し考えたり，じっくり考えたりすることは決してない。', reverse: true },
      { id: 10, text: '不愉快な考えを頭の中から外へ出すことはたやすい。', reverse: true },
      { id: 11, text: 'もはや関心を持つべきではない人生の出来事について熟考することがよくある。', reverse: false },
      { id: 12, text: '私は，恥ずかしい，あるいはがっかりした瞬間を思い返すのに，非常に多くの時間を費やしている。', reverse: false }
    ],
    reflection: [
      { id: 13, text: '哲学的，抽象的な考えは，それほど私の興味を引くものではない。', reverse: true },
      { id: 14, text: '私はそれほど物事を深く考えるタイプの人ではない。', reverse: true },
      { id: 15, text: '「内的な」自己を探るのがとても好きだ。', reverse: false },
      { id: 16, text: '物事に対する自分の態度や気持ちに，強い興味がある。', reverse: false },
      { id: 17, text: '内省的，自省的な考え方は本当に好きではない。', reverse: true },
      { id: 18, text: 'なぜそうするのかを分析するのがとても好きだ。', reverse: false },
      { id: 19, text: '私は，「深い」，内省的なタイプの人だとよく人に言われる。', reverse: false },
      { id: 20, text: '自己分析はあまり好きではない。', reverse: true },
      { id: 21, text: 'もともと自己をとても探求したいと思っている。', reverse: false },
      { id: 22, text: 'ものごとの本質や意味について深く考えることがとても好きだ。', reverse: false },
      { id: 23, text: '自分の人生を哲学的に見ることがとても好きだとしばしば思う。', reverse: false },
      { id: 24, text: '自分自身についてじっくり考えることは，楽しいとは思わない。', reverse: true }
    ]
  };

  const TOTAL_ITEMS = RRQ.rumination.length + RRQ.reflection.length;
  const ITEM_LOOKUP = {
    R: Object.fromEntries(RRQ.rumination.map((item, index) => [index + 1, item])),
    F: Object.fromEntries(RRQ.reflection.map((item, index) => [index + 1, item]))
  };

  // システム情報と開始時刻を取得して全トライアルに記録
  const systemInfo = getSystemInfo();
  const startTimestamp = Date.now();
  const startTimeJST = getJapanTime(startTimestamp);
  
  jsPsych.data.addProperties({
    browser: systemInfo.browser,
    os: systemInfo.os,
    user_agent: systemInfo.user_agent,
    start_time_jst: startTimeJST,
    start_timestamp: startTimestamp
  });

  const allItems = createQuestionPool();
  jsPsych.data.addProperties({
    rrq_item_order: JSON.stringify(allItems.map(({ domain, id, originalId, text }) => ({ domain, id, originalId, text })))
  });
  const pages = chunkArray(allItems, PAGE_SIZE);

  // ==========================================
  // 2. タイムラインの構築
  // ==========================================
  const intro = createIntroTrial();
  const demographics = createDemographicsTrial();
  const likertPages = pages.map((items, index) => createLikertPage(items, index));
  const subjectId = jsPsych.randomization.randomID(10);
  jsPsych.data.addProperties({ subject_id: subjectId });
  const saveDataTrial = createSaveTrial(subjectId);
  let lastSummary = null;
  const results = createResultsTrial();

  const timeline = [intro, demographics, ...likertPages, saveDataTrial, results];
  jsPsych.run(timeline);

  // ==========================================
  // 3. DOM 初期化系関数
  // ==========================================
  function setProgressLabelToJapanese() {
    const trySetLabel = () => {
      const span = document.querySelector('#jspsych-progressbar-container span');
      if (span) {
        span.innerHTML = PROGRESS_LABEL_TEXT;
        return true;
      }
      return false;
    };

    if (trySetLabel()) return;

    const observer = new MutationObserver((_, obs) => {
      if (trySetLabel()) obs.disconnect();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }

  function injectResultStyles() {
    const styleEl = document.createElement('style');
    styleEl.innerHTML = `
      .description-box { background: linear-gradient(90deg,#f5f9ff,#fbfdff); border-left:6px solid #1976D2; padding:1rem; border-radius:6px; }
      .description-box .score-label { font-weight:700; font-size:1rem; color:#0d47a1; margin-bottom:0.25rem; }
      .description-box p { margin:0 0 0.6rem 0; line-height:1.45; }
    `;
    document.head.appendChild(styleEl);
  }

  // ==========================================
  // 4. データ準備ヘルパー
  // ==========================================
  
  /**
   * システム情報を取得する関数
   * ユーザーエージェント文字列からブラウザとOSを判定
   * @returns {Object} browser, os, user_agent を含むオブジェクト
   */
  function getSystemInfo() {
    const ua = navigator.userAgent;
    let browser = 'Unknown';
    let os = 'Unknown';
    
    // ブラウザの判定
    if (ua.indexOf('Edg') > -1) browser = 'Edge';
    else if (ua.indexOf('Chrome') > -1) browser = 'Chrome';
    else if (ua.indexOf('Safari') > -1) browser = 'Safari';
    else if (ua.indexOf('Firefox') > -1) browser = 'Firefox';
    else if (ua.indexOf('Opera') > -1 || ua.indexOf('OPR') > -1) browser = 'Opera';
    
    // OSの判定
    if (ua.indexOf('Win') > -1) os = 'Windows';
    else if (ua.indexOf('Mac') > -1) os = 'macOS';
    else if (ua.indexOf('Linux') > -1) os = 'Linux';
    else if (ua.indexOf('Android') > -1) os = 'Android';
    else if (ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) os = 'iOS';
    
    return { browser, os, user_agent: ua };
  }
  
  /**
   * 日本時間の文字列を取得する関数
   * @param {number} timestamp - タイムスタンプ（ミリ秒）。省略時は現在時刻
   * @returns {string} 日本時間の文字列（例: "2025/10/22 14:30:45"）
   */
  function getJapanTime(timestamp) {
    const date = timestamp ? new Date(timestamp) : new Date();
    return date.toLocaleString('ja-JP', { 
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    }).replace(/\//g, '/').replace(',', '');
  }
  
  function createQuestionPool() {
    const merged = [
      ...RRQ.rumination.map((item, index) => ({
        text: item.text,
        reverse: item.reverse,
        domain: 'R',
        id: index + 1,
        originalId: item.id
      })),
      ...RRQ.reflection.map((item, index) => ({
        text: item.text,
        reverse: item.reverse,
        domain: 'F',
        id: index + 1,
        originalId: item.id
      }))
    ];

    return shuffleInPlace(merged);
  }

  function updateProgressBar(fraction) {
    const barInner = document.querySelector('#jspsych-progressbar-inner');
    if (!barInner) return;
    const clamped = Math.max(0, Math.min(1, fraction));
    barInner.style.width = `${Math.round(clamped * 100)}%`;
  }

  function chunkArray(arr, size) {
    const result = [];
    for (let i = 0; i < arr.length; i += size) {
      result.push(arr.slice(i, i + size));
    }
    return result;
  }

  function shuffleInPlace(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // ==========================================
  // 5. トライアル生成ヘルパー
  // ==========================================
  function createIntroTrial() {
    return {
      type: window.jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="card">
          <h2>RRQ 日本語版</h2>
          <h3>Rumination–Reflection Questionnaire</h3>
          <h4>「感情・人格心理学」受講者用</h4>
          <p style="margin:0.6rem 0 0;">
            これは反芻と内省傾向を測定するアンケートであり，講義内容の理解を促進するために利用されます。<br>この結果だけで医学的診断を行ったり，あなたの性格そのものを測定することはできませんので注意してください。<br>データは保管されますが，個人が特定されることはなく，回答の有無が成績に影響することは一切ありません。
          </p>
          <ul class="small muted" style="margin-top:0.8rem; padding-left:1.2rem;">
            回答時間の目安：4〜6分<br>
            出典：高野慶輔・丹野義彦 (2008). Rumination–Reflection Questionnaire 日本語版作成の試み. パーソナリティ研究, 16, 259–261.
          </ul>
        </div>
      `,
      choices: ['開始']
    };
  }

  function createDemographicsTrial() {
    return {
      type: window.jsPsychSurvey,
      survey_json: {
        showQuestionNumbers: false,
        pages: [{
          name: 'demographics',
          elements: [
            {
              type: 'text',
              name: 'age',
              title: '年齢',
              inputType: 'number',
              isRequired: true
            },
            {
              type: 'dropdown',
              name: 'gender',
              title: '性別',
              isRequired: true,
              choices: ['男性','女性','その他','未回答']
            }
          ]
        }],
        pageNextText: '次へ',
        completeText: '次へ'
      },
      on_finish: (data) => {
        const response = data.response || {};
        jsPsych.data.addProperties({
          age: response.age || '',
          gender: response.gender || ''
        });
      }
    };
  }

  function createLikertPage(items, pageIndex) {
    const pageStart = pageIndex * PAGE_SIZE + 1;
    const pageEnd = pageStart + items.length - 1;
    const isLastPage = pageIndex === pages.length - 1;

    return {
      type: window.jsPsychSurvey,
      survey_json: {
        showQuestionNumbers: false,
        pages: [{
          name: `page_${pageIndex}`,
          elements: [
            {
              type: 'html',
              name: `preamble_${pageIndex}`,
              html: `
                <div class="card">
                  <b>質問 ${pageStart}–${pageEnd} / ${TOTAL_ITEMS}</b>
                  <p style="margin:0.5rem 0 0;">
                    以下の各文について、あなたがどの程度当てはまるかを1つ選んでください。直感的に答えて構いません。
                  </p>
                </div>
              `
            },
            ...items.map(item => ({
              type: 'radiogroup',
              name: `${item.domain}${item.id}`,
              title: item.text,
              isRequired: true,
              choices: LIKERT_CHOICES.map(choice => ({ ...choice }))
            }))
          ]
        }],
        pageNextText: '次へ',
        completeText: isLastPage ? '結果を見る' : '次へ'
      },
      on_load: () => {
        debugLog('Loaded RRQ survey page', { pageIndex, pageStart, pageEnd });
        updateProgressBar(pageEnd / TOTAL_ITEMS);
      },
      on_finish: (data) => {
        // ページ番号を記録（1-based）
        data.page_number = pageIndex + 1;
        
        // このページで回答した項目のリスト（domain:id形式、例: "R1,F3,R5"）
        const pageItemsList = items.map(item => `${item.domain}${item.id}`).join(',');
        data.page_items = pageItemsList;
        
        // 各回答について逆転項目を考慮した得点を記録
        const resp = data.response || {};
        Object.entries(resp).forEach(([name, value]) => {
          // 変数名から該当する項目を検索（例: "R1" → domain='R', id=1）
          const item = items.find(it => `${it.domain}${it.id}` === name);
          if (!item) return;
          
          // 回答値を数値に変換（survey プラグインの場合）
          let rawScore = null;
          if (typeof value === 'number') {
            rawScore = value;
          } else if (typeof value === 'string') {
            rawScore = Number(value);
          } else if (value && typeof value === 'object' && 'value' in value) {
            rawScore = Number(value.value);
          }
          
          if (rawScore == null || !Number.isFinite(rawScore)) return;
          
          // 1-5の範囲に収める
          if (rawScore < 1 || rawScore > 5) return;
          
          // 逆転項目の場合は反転処理（6 - 値）
          const scoredValue = item.reverse ? (6 - rawScore) : rawScore;
          
          // CSVに記録する変数を追加
          data[`${name}_raw`] = rawScore;           // 生得点（1-5）
          data[`${name}_scored`] = scoredValue;      // 逆転処理済み得点
          data[`${name}_reversed`] = item.reverse;   // 逆転項目かどうか
          data[`${name}_original_id`] = item.originalId; // 元の項目番号
        });
        
        debugLog('Page finished', { pageIndex, pageItemsList });
      }
    };
  }

  function createSaveTrial(subjectId) {
    return {
      type: window.jsPsychPipe,
      action: 'save',
      experiment_id: 'LtNw0mBEbED7',
      filename: `${subjectId}.csv`,
      data_string: () => jsPsych.data.get().csv()
    };
  }

  function createResultsTrial() {
    return {
      type: window.jsPsychHtmlButtonResponse,
      stimulus: () => {
        const summary = computeSummary();
        lastSummary = summary;
        return createResultsHtml(summary);
      },
      choices: ['終了'],
      on_finish: () => {
        // 終了時刻と所要時間を記録
        const endTimestamp = Date.now();
        const endTimeJST = getJapanTime(endTimestamp);
        const durationMs = endTimestamp - startTimestamp;
        const durationSec = durationMs / 1000;
        const durationMin = durationSec / 60;
        
        // 全データに終了時刻と所要時間を追加
        jsPsych.data.addProperties({
          end_time_jst: endTimeJST,
          end_timestamp: endTimestamp,
          total_duration_ms: durationMs,
          total_duration_sec: parseFloat(durationSec.toFixed(2)),
          total_duration_min: parseFloat(durationMin.toFixed(2))
        });
        
        window.location.href = 'https://mshrymgc.github.io/epp_scales/';
      },
      on_load: () => {
        if (!lastSummary) {
          debugLog('結果表示のための集計が見つかりません');
          return;
        }
        renderResultsChart(lastSummary);
      }
    };
  }

  // ==========================================
  // 6. 回答処理ロジック
  // ==========================================
  function getResponses() {
    const responses = { R: {}, F: {} };

    const surveyTrials = jsPsych.data.get()
      .filter(trial => trial.trial_type && (trial.trial_type === 'survey-likert' || trial.trial_type === 'survey'))
      .values();

    surveyTrials.forEach((trial, trialIndex) => {
      const trialResponse = trial.response || {};
      debugLog(`Trial ${trialIndex}`, trialResponse);

      Object.entries(trialResponse).forEach(([name, value]) => {
        const match = /^([RF])(\d+)$/.exec(String(name));
        if (!match) return;

        const domain = match[1];
        const id = Number(match[2]);
        const numeric = parseLikertValue(value);
        if (numeric == null) return;

        responses[domain][id] = numeric;
      });
    });

    debugLog('Collected responses', responses);
    return responses;
  }

  function parseLikertValue(value) {
    if (typeof value === 'number' && Number.isFinite(value)) {
      // survey-likert プラグインは 0 始まりのインデックスを返すため補正
      if (value >= 0 && value <= 4) {
        return value + 1;
      }
      return value;
    }
    if (typeof value === 'string') {
      const parsed = Number(value);
      return Number.isNaN(parsed) ? null : parsed;
    }
    if (value && typeof value === 'object') {
      if ('value' in value) {
        return parseLikertValue(value.value);
      }
      const fallback = parseInt(JSON.stringify(value), 10);
      return Number.isNaN(fallback) ? null : fallback;
    }
    return null;
  }

  function computeSummary() {
    const responses = getResponses();
    const base = {
      rumination: { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0, 0] },
      reflection: { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0, 0] }
    };

    ['R', 'F'].forEach((domain) => {
      const store = domain === 'R' ? base.rumination : base.reflection;
      const domainResponses = responses[domain] || {};

      Object.entries(domainResponses).forEach(([idStr, rawValue]) => {
        const id = Number(idStr);
        if (!Number.isFinite(id)) return;

        const raw = Number(rawValue);
        if (!Number.isFinite(raw)) return;

        const meta = findItem(domain, id);
        const scored = meta && meta.reverse ? 6 - raw : raw;

        store.count += 1;
        if (raw >= 1 && raw <= 5) {
          store.counts[raw - 1] += 1;
        }
        store.sum += scored;
      });

      if (store.count > 0) {
        store.mean = store.sum / store.count;
      }
    });

    debugLog('Summary result', base);
    return base;
  }

  function findItem(domain, id) {
    return ITEM_LOOKUP[domain]?.[id] || null;
  }

  // ==========================================
  // 7. 表示用ユーティリティ
  // ==========================================
  function createResultsHtml(summary) {
    const rumRow = `<tr><td>反芻 (Rumination)</td><td>${formatInt(summary.rumination.sum)} / 60</td><td>${formatMean(summary.rumination.mean)}</td></tr>`;
    const refRow = `<tr><td>省察 (Reflection)</td><td>${formatInt(summary.reflection.sum)} / 60</td><td>${formatMean(summary.reflection.mean)}</td></tr>`;

    return `
      <div class="card">
        <h2>結果</h2>
        <p style="margin:0.4rem 0 0.8rem;">
          各下位尺度は12項目・5件法で構成され，合計得点の範囲は12〜60です。平均値（1〜5）は逆転項目を処理した後に算出しています。
        </p>
        <table>
          <thead>
            <tr><th>特性</th><th>合計得点</th><th>平均 (1〜5)</th></tr>
          </thead>
          <tbody>${rumRow}${refRow}</tbody>
        </table>
        <div class="result-grid">
          <div style="grid-column:1/-1">
            <h3 style="margin:1rem 0 0.5rem;">反芻と省察の合計得点</h3>
            <div class="chart-wrap chart-small"><canvas id="rrq-chart"></canvas></div>
            <div id="rrq-values" style="margin-top:0.6rem; font-weight:600; text-align:center;">
              合計（反芻 / 省察）: ${formatInt(summary.rumination.sum)} / ${formatInt(summary.reflection.sum)}　
              平均（反芻 / 省察）: ${formatMean(summary.rumination.mean)} / ${formatMean(summary.reflection.mean)}
            </div>
            <div class="description-box" style="margin-top:0.8rem;">
              <div class="score-label">反芻（Rumination）</div>
              <p style="margin:0.2rem 0 0;">
                ネガティブな出来事や気分に対して，同じことを繰り返し考え続ける傾向。問題解決ではなく思考が堂々巡りになりやすい場合は心理的負担が増すことがあります。
              </p>
              <div class="score-label" style="margin-top:0.6rem;">省察（Reflection）</div>
              <p style="margin:0.2rem 0 0;">
                自分の感情や行動を振り返り，経験から学ぼうとする傾向。建設的な内省が高いほど，自己理解や成長への関心が高いことを示します。
              </p>
            </div>
          </div>
        </div>
        <div class="small muted" style="margin-top:1rem;">
          注：高野慶輔・丹野義彦 (2008). Rumination–Reflection Questionnaire 日本語版作成の試み. パーソナリティ研究, 16, 259–261.
        </div>
      </div>
    `;
  }

  function renderResultsChart(summary) {
    const canvas = document.getElementById('rrq-chart');
    if (!canvas) {
      debugLog('結果グラフ用の canvas が見つかりません');
      return;
    }

    if (window.rrqChart && typeof window.rrqChart.destroy === 'function') {
      window.rrqChart.destroy();
    }

    const ruminationScore = Number(summary.rumination.sum) || 0;
    const reflectionScore = Number(summary.reflection.sum) || 0;

    const valuesEl = document.getElementById('rrq-values');
    if (valuesEl) {
      valuesEl.innerText = (
        `合計（反芻 / 省察）: ${formatInt(ruminationScore)} / ${formatInt(reflectionScore)}　` +
        `平均（反芻 / 省察）: ${formatMean(summary.rumination.mean)} / ${formatMean(summary.reflection.mean)}`
      );
    }

    window.rrqChart = new Chart(canvas.getContext('2d'), {
      type: 'bar',
      data: {
        labels: ['反芻 (R)', '省察 (F)'],
        datasets: [{
          label: '合計得点 (12〜60)',
          data: [ruminationScore, reflectionScore],
          backgroundColor: ['rgba(25,118,210,0.85)', 'rgba(56,142,60,0.85)']
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          y: {
            min: 12,
            max: 60,
            ticks: { stepSize: 6 },
            title: { display: true, text: '合計得点 (12〜60)' }
          }
        }
      }
    });

    try {
      window.rrqChart.update();
    } catch (error) {
      debugLog('Chart update failed', error);
    }
  }

  function formatInt(value) {
    if (value == null) return '-';
    return Math.round(value).toString();
  }

  function formatMean(value) {
    if (value == null) return '-';
    const numeric = Number(value);
    return Number.isNaN(numeric) ? '-' : numeric.toFixed(2);
  }
})();
  </script>
</body>
</html>
