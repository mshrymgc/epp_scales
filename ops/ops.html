<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>楽観・悲観性尺度</title>
  <link rel="stylesheet" href="../dist/jspsych.css" />
  <link rel="stylesheet" href="../dist/survey.min.css" />
  <style>
    /* ==========================================
       基本スタイル
       ========================================== */
    body { 
      font-family: system-ui, sans-serif; 
    }
    
    /* カード型のコンテナ */
    .card { 
      background: #fff; 
      border: 1px solid #eee; 
      border-radius: 12px; 
      padding: 1rem; 
    }
    
    /* グリッドレイアウト */
    .grid { 
      display: grid; 
      gap: 1rem; 
    }
    
    /* 結果画面のグリッド */
    .result-grid { 
      display: grid; 
      gap: 1.2rem; 
      margin-top: 1.5rem; 
    }
    
    /* レスポンシブ: 780px以上で2カラム表示 */
    @media (min-width: 780px) { 
      .result-grid { 
        grid-template-columns: repeat(2, minmax(0, 1fr)); 
        align-items: start; 
      } 
    }
    
    /* ==========================================
       グラフ関連
       ========================================== */
    /* グラフのラッパー */
    .chart-wrap { 
      position: relative; 
      width: 100%; 
      max-width: 500px; 
      margin: 0 auto; 
    }
    
    /* 小さいサイズのグラフ */
    .chart-small { 
      height: 260px; 
      max-height: 320px; 
    }
    
    /* グラフのcanvas要素 */
    .chart-wrap canvas { 
      display: block; 
      width: 100%; 
      height: 100%; 
    }
    
    /* ==========================================
       テーブルスタイル
       ========================================== */
    table { 
      border-collapse: collapse; 
      width: 100%; 
    }
    
    th, td { 
      padding: 0.45rem 0.4rem; 
      border-bottom: 1px solid #eee; 
      text-align: left; 
      font-size: 0.95rem; 
    }
    
    th { 
      font-weight: 600; 
      background: #fafafa; 
    }
    
    /* ==========================================
       ユーティリティクラス
       ========================================== */
    /* 小さい文字 */
    .small { 
      font-size: 0.85rem; 
    }
    
    /* グレーの文字 */
    .muted { 
      color: #666; 
    }
    
    /* ==========================================
       ツールチップ（ホバー時の説明表示）
       ========================================== */
    .likert-label-tooltip { 
      position: relative; 
    }
    
    .likert-label-tooltip::after { 
      content: attr(data-tooltip); 
      position: absolute; 
      bottom: 120%; 
      left: 50%; 
      transform: translateX(-50%); 
      background: #333; 
      color: #fff; 
      padding: 0.4rem 0.6rem; 
      border-radius: 4px; 
      white-space: nowrap; 
      font-size: 0.8rem; 
      opacity: 0; 
      transition: opacity 0.15s ease; 
      pointer-events: none; 
      z-index: 10; 
    }
    
    .likert-label-tooltip:hover::after { 
      opacity: 1; 
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="../dist/jspsych.js"></script>
  <script src="../dist/plugin-html-button-response.js"></script>
  <script src="../dist/plugin-survey.js"></script>
  <script src="../dist/plugin-survey-likert.js"></script>
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe@0.5.0/dist/index.browser.min.js"></script>
</head>
<body>
  <div id="jspsych-target"></div>
  <script>
(() => {
  // ==========================================
  // 0. jsPsych の初期化と基本設定
  // ==========================================
  const PROGRESS_LABEL_TEXT = '進捗状況'; // 進捗バーに表示するテキスト
  const PAGE_SIZE = 10; // 1ページに表示する質問数
  const LIKERT_CHOICES = [
    { value: 1, text: '1 = 全く当てはまらない' },
    { value: 2, text: '2 = 当てはまらない' },
    { value: 3, text: '3 = 当てはまる' },
    { value: 4, text: '4 = よく当てはまる' }
  ];
  const DEBUG = false; // true にするとコンソールに詳細ログを表示
  const debugLog = (...args) => { if (DEBUG) console.log(...args); };

  const jsPsych = window.jsPsychModule.initJsPsych({
    display_element: 'jspsych-target',
    show_progress_bar: true,
    auto_update_progress_bar: false
  });

  // ==========================================
  // システム情報・時間情報の取得と記録
  // ==========================================
  
  /**
   * ブラウザとOS情報を取得する関数
   * @returns {Object} { browser, os, userAgent }
   */
  const getSystemInfo = () => {
    const ua = navigator.userAgent;
    let browser = 'Unknown';
    let os = 'Unknown';
    
    // ブラウザの判定
    if (ua.indexOf('Firefox') > -1) {
      browser = 'Firefox';
    } else if (ua.indexOf('Opera') > -1 || ua.indexOf('OPR') > -1) {
      browser = 'Opera';
    } else if (ua.indexOf('Trident') > -1) {
      browser = 'Internet Explorer';
    } else if (ua.indexOf('Edge') > -1 || ua.indexOf('Edg') > -1) {
      browser = 'Edge';
    } else if (ua.indexOf('Chrome') > -1) {
      browser = 'Chrome';
    } else if (ua.indexOf('Safari') > -1) {
      browser = 'Safari';
    }
    
    // OSの判定
    if (ua.indexOf('Win') > -1) {
      os = 'Windows';
    } else if (ua.indexOf('Mac') > -1) {
      os = 'macOS';
    } else if (ua.indexOf('Linux') > -1) {
      os = 'Linux';
    } else if (ua.indexOf('Android') > -1) {
      os = 'Android';
    } else if (ua.indexOf('iOS') > -1 || ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) {
      os = 'iOS';
    }
    
    return { browser, os, userAgent: ua };
  };
  
  /**
   * 日本時間（JST）で現在時刻を取得する関数
   * @returns {string} 日時文字列（日本時間）
   */
  const getJapanTime = () => {
    return new Date().toLocaleString('ja-JP', { 
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });
  };
  
  // 実験開始時刻を記録（ミリ秒単位のタイムスタンプ）
  const experimentStartTime = Date.now();
  
  // システム情報を取得
  const systemInfo = getSystemInfo();
  
  // 開始時刻（日本時間）を記録
  const startTimeJST = getJapanTime();
  
  // これらの情報をjsPsychのデータに追加
  jsPsych.data.addProperties({
    browser: systemInfo.browser,
    os: systemInfo.os,
    user_agent: systemInfo.userAgent,
    start_time_jst: startTimeJST,
    start_timestamp: experimentStartTime
  });

  setProgressLabelToJapanese();
  injectResultStyles();

  // ==========================================
  // 1. 尺度項目の定義
  // ==========================================
  const OPS = {
    optimism: [
      { id: 1, text: '自分の将来は、良いことが起こると思う', reverse: false },
      { id: 3, text: '将来、幸せになれると思う', reverse: false },
      { id: 5, text: '私は将来に対して、前向きに考えている', reverse: false },
      { id: 7, text: '自分の将来は、恵まれていると思う', reverse: false },
      { id: 9, text: '自分の将来に期待がもてる', reverse: false },
      { id: 11, text: 'これからの人生は良いものになるだろうと思う', reverse: false },
      { id: 13, text: '結果が予想できない時は、良い方向に期待する', reverse: false },
      { id: 15, text: '私には、悪いことよりも良いことが起こると思う', reverse: false },
      { id: 17, text: '何かに取りかかる時は、成功するだろうと考える', reverse: false },
      { id: 19, text: '自分の将来を楽しみにしている', reverse: false }
    ],
    pessimism: [
      { id: 2, text: '私の将来は、暗いと思う', reverse: false },
      { id: 4, text: '望ましくない、未来の自分の姿ばかりを想像する', reverse: false },
      { id: 6, text: '何もかもが悪い方向にしか進まないだろうと思う', reverse: false },
      { id: 8, text: '私の望みは叶わないと思う', reverse: false },
      { id: 10, text: '自分の将来に絶望している', reverse: false },
      { id: 12, text: '何かを計画する時、失敗している自分の姿が頭に浮かぶ', reverse: false },
      { id: 14, text: '何をしても、うまくいかないことばかりを想像する', reverse: false },
      { id: 16, text: '結局、自分の目標は達成できないだろう', reverse: false },
      { id: 18, text: '今後のことを考えると、悪いことばかりが頭に浮かぶ', reverse: false },
      { id: 20, text: '何かに取りかかる時は、失敗するだろうと考える', reverse: false }
    ]
  };

  const TOTAL_ITEMS = OPS.optimism.length + OPS.pessimism.length;
  const ITEM_LOOKUP = {
    O: Object.fromEntries(OPS.optimism.map(item => [item.id, item])),
    P: Object.fromEntries(OPS.pessimism.map(item => [item.id, item]))
  };

  const allItems = createQuestionPool();
  jsPsych.data.addProperties({
    ops_item_order: JSON.stringify(allItems.map(({ domain, id, text }) => ({ domain, id, text })))
  });
  const pages = chunkArray(allItems, PAGE_SIZE);

  // ==========================================
  // 2. タイムラインの構築
  // ==========================================
  const intro = createIntroTrial();
  const demographics = createDemographicsTrial();
  const likertPages = pages.map((items, index) => createLikertPage(items, index));
  const subjectId = jsPsych.randomization.randomID(10);
  jsPsych.data.addProperties({ subject_id: subjectId });
  const saveDataTrial = createSaveTrial(subjectId);
  let lastSummary = null;
  const results = createResultsTrial();

  const timeline = [intro, demographics, ...likertPages, saveDataTrial, results];
  jsPsych.run(timeline);

  // ==========================================
  // 3. DOM 初期化系関数
  // ==========================================
  function setProgressLabelToJapanese() {
    // 進捗バーが生成されたタイミングでラベルを「進捗状況」に差し替える
    const trySetLabel = () => {
      const span = document.querySelector('#jspsych-progressbar-container span');
      if (span) {
        span.innerHTML = PROGRESS_LABEL_TEXT;
        return true;
      }
      return false;
    };

    if (trySetLabel()) return;

    const observer = new MutationObserver((_, obs) => {
      if (trySetLabel()) obs.disconnect();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }

  function injectResultStyles() {
    // 結果画面のハイライト用スタイルを追加
    const styleEl = document.createElement('style');
    styleEl.innerHTML = `
      .description-box { background: linear-gradient(90deg,#f5f9ff,#fbfdff); border-left:6px solid #1976D2; padding:1rem; border-radius:6px; }
      .description-box .score-label { font-weight:700; font-size:1rem; color:#0d47a1; margin-bottom:0.25rem; }
      .description-box p { margin:0 0 0.6rem 0; line-height:1.45; }
    `;
    document.head.appendChild(styleEl);
  }

  // ==========================================
  // 4. データ準備ヘルパー
  // ==========================================
  function createQuestionPool() {
    // 楽観性・悲観性の項目を1つのリストにまとめ、順序をシャッフルする
    const merged = [
      ...OPS.optimism.map(item => ({
        text: item.text,
        reverse: item.reverse,
        domain: 'O',
        id: item.id
      })),
      ...OPS.pessimism.map(item => ({
        text: item.text,
        reverse: item.reverse,
        domain: 'P',
        id: item.id
      }))
    ];

    return shuffleInPlace(merged);
  }

  function updateProgressBar(fraction) {
    const barInner = document.querySelector('#jspsych-progressbar-inner');
    if (!barInner) return;
    const clamped = Math.max(0, Math.min(1, fraction));
    barInner.style.width = `${Math.round(clamped * 100)}%`;
  }

  function chunkArray(arr, size) {
    const result = [];
    for (let i = 0; i < arr.length; i += size) {
      result.push(arr.slice(i, i + size));
    }
    return result;
  }

  function shuffleInPlace(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // ==========================================
  // 5. トライアル生成ヘルパー
  // ==========================================
  function createIntroTrial() {
    // 最初に表示する説明画面
    return {
      type: window.jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="card">
          <h2>楽観・悲観性尺度</h2>
          <p style="margin:0.6rem 0 0;">
            これは楽観傾向と悲観傾向を測定するアンケートであり，講義内容の理解を促進するために利用されます。<br>この結果だけで医学的診断を行ったり，あなたの性格そのものを測定することはできませんので注意してください。<br>データは保管されますが，個人が特定されることはなく，回答の有無が成績に影響することは一切ありません。
          </p>
          <ul class="small muted" style="margin-top:0.8rem; padding-left:1.2rem;">
            回答時間の目安：3〜5分<br>
            出典：外山美樹. (2013). 楽観・悲観性尺度の作成ならびに信頼性・妥当性の検討. 心理学研究, 84(3), 256–266. 
            https://doi.org/10.4992/jjpsy.84.256
          </ul>
        </div>
      `,
      choices: ['開始']
    };
  }

  function createDemographicsTrial() {
    // 年齢・性別など基本情報を1ページで取得する
    return {
      type: window.jsPsychSurvey,
      survey_json: {
        showQuestionNumbers: false,
        pages: [{
          name: 'demographics',
          elements: [
            {
              type: 'text',
              name: 'age',
              title: '年齢',
              inputType: 'number',
              isRequired: true
            },
            {
              type: 'dropdown',
              name: 'gender',
              title: '性別',
              isRequired: true,
              choices: ['男性','女性','その他','未回答']
            }
          ]
        }],
        pageNextText: '次へ',
        completeText: '次へ'
      },
      on_finish: (data) => {
        const response = data.response || {};
        jsPsych.data.addProperties({
          age: response.age || '',
          gender: response.gender || ''
        });
      }
    };
  }

  function createLikertPage(items, pageIndex) {
    // 質問を10件ずつまとめた画面を生成
    const pageStart = pageIndex * PAGE_SIZE + 1;
    const pageEnd = pageStart + items.length - 1;
    const isLastPage = pageIndex === pages.length - 1;

    return {
      type: window.jsPsychSurvey,
      survey_json: {
        showQuestionNumbers: false,
        pages: [{
          name: `page_${pageIndex}`,
          elements: [
            {
              type: 'html',
              name: `preamble_${pageIndex}`,
              html: `
                <div class="card">
                  <b>質問 ${pageStart}–${pageEnd} / ${TOTAL_ITEMS}</b>
                  <p style="margin:0.5rem 0 0;">
                    以下の各文について、あなたがどの程度当てはまるかを1つ選んでください。直感的に答えて構いません。
                  </p>
                </div>
              `
            },
            ...items.map(item => ({
              type: 'radiogroup',
              name: `${item.domain}${item.id}`,
              title: item.text,
              isRequired: true,
              choices: LIKERT_CHOICES.map(choice => ({ ...choice }))
            }))
          ]
        }],
        pageNextText: '次へ',
        completeText: isLastPage ? '結果を見る' : '次へ'
      },
      // データ記録用: このページで回答した項目のリストを保存
      data: {
        page_number: pageIndex,
        page_items: items.map(it => `${it.domain}${it.id}`).join(',')
      },
      on_load: () => {
        debugLog('Loaded survey page', { pageIndex, pageStart, pageEnd });
        updateProgressBar(pageEnd / TOTAL_ITEMS);
      }
    };
  }

  function createSaveTrial(subjectId) {
    // DataPipe を使って回答データをサーバーに保存
    return {
      type: window.jsPsychPipe,
      action: 'save',
      experiment_id: 'rEHu7dVHdN1Z',
      filename: `${subjectId}.csv`,
      data_string: () => jsPsych.data.get().csv()
    };
  }

  function createResultsTrial() {
    // 集計結果を表示する画面
    return {
      type: window.jsPsychHtmlButtonResponse,
      stimulus: () => {
        const summary = computeSummary();
        lastSummary = summary;
        
        // 終了時刻と所要時間を計算
        const endTimeJST = getJapanTime();
        const experimentEndTime = Date.now();
        const totalDurationMs = experimentEndTime - experimentStartTime;
        const totalDurationSec = Math.round(totalDurationMs / 1000);
        const totalDurationMin = (totalDurationSec / 60).toFixed(2);
        
        // これらの情報をjsPsychのデータに追加
        jsPsych.data.addProperties({
          end_time_jst: endTimeJST,
          end_timestamp: experimentEndTime,
          total_duration_ms: totalDurationMs,
          total_duration_sec: totalDurationSec,
          total_duration_min: totalDurationMin
        });
        
        return createResultsHtml(summary);
      },
      choices: ['終了'],
      on_finish: () => {
        window.location.href = 'https://mshrymgc.github.io/epp_scales/';
      },
      on_load: () => {
        if (!lastSummary) {
          debugLog('結果表示のための集計が見つかりません');
          return;
        }
        renderResultsChart(lastSummary);
      }
    };
  }

  // ==========================================
  // 6. 回答処理ロジック
  // ==========================================
  function getResponses() {
    // jsPsych に蓄積されたデータから回答部分だけを抽出
    const responses = { O: {}, P: {} };

    const surveyTrials = jsPsych.data.get()
      .filter(trial => trial.trial_type && (trial.trial_type === 'survey-likert' || trial.trial_type === 'survey'))
      .values();

    surveyTrials.forEach((trial, trialIndex) => {
      const trialResponse = trial.response || {};
      debugLog(`Trial ${trialIndex}`, trialResponse);

      Object.entries(trialResponse).forEach(([name, value]) => {
        const match = /^([OP])(\d+)$/.exec(String(name));
        if (!match) return;

        const domain = match[1];
        const id = Number(match[2]);
        const numeric = parseLikertValue(value);
        if (numeric == null) return;

        responses[domain][id] = numeric;
      });
    });

    debugLog('Collected responses', responses);
    return responses;
  }

  function parseLikertValue(value) {
    // ラジオボタンの回答が数値として扱えるように統一的に変換
    if (typeof value === 'number' && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === 'string') {
      const parsed = Number(value);
      return Number.isNaN(parsed) ? null : parsed;
    }
    if (value && typeof value === 'object') {
      if ('value' in value) {
        return parseLikertValue(value.value);
      }
      const fallback = parseInt(JSON.stringify(value), 10);
      return Number.isNaN(fallback) ? null : fallback;
    }
    return null;
  }

  function computeSummary() {
    // 集計値（合計・平均・回答分布）を楽観性・悲観性ごとに算出
    const responses = getResponses();
    const base = {
      optimism: { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0] },
      pessimism: { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0] }
    };

    ['O', 'P'].forEach((domain) => {
      const store = domain === 'O' ? base.optimism : base.pessimism;
      const domainResponses = responses[domain] || {};

      Object.entries(domainResponses).forEach(([idStr, rawValue]) => {
        const id = Number(idStr);
        if (!Number.isFinite(id)) return;

        const raw = Number(rawValue);
        if (!Number.isFinite(raw)) return;

        const meta = findItem(domain, id);
        const scored = meta && meta.reverse ? 5 - raw : raw;

        store.count += 1;
        if (raw >= 1 && raw <= 4) {
          store.counts[raw - 1] += 1;
        }
        store.sum += scored;
      });

      if (store.count > 0) {
        store.mean = store.sum / store.count;
      }
    });

    debugLog('Summary result', base);
    return base;
  }

  function findItem(domain, id) {
    return ITEM_LOOKUP[domain]?.[id] || null;
  }

  // ==========================================
  // 7. 表示用ユーティリティ
  // ==========================================
  function createResultsHtml(summary) {
    const optRow = `<tr><td>楽観性 (Optimism)</td><td>${formatInt(summary.optimism.sum)} / 40</td><td>${formatMean(summary.optimism.mean)}</td></tr>`;
    const pesRow = `<tr><td>悲観性 (Pessimism)</td><td>${formatInt(summary.pessimism.sum)} / 40</td><td>${formatMean(summary.pessimism.mean)}</td></tr>`;

    return `
      <div class="card">
        <h2>結果</h2>
        <p style="margin:0.4rem 0 0.8rem;">
          各下位尺度は10項目・4件法で構成され，合計得点の範囲は10〜40です。平均値（1〜4）は逆転項目を処理した後に算出しています。
        </p>
        <table>
          <thead>
            <tr><th>特性</th><th>合計得点</th><th>平均 (1〜4)</th></tr>
          </thead>
          <tbody>${optRow}${pesRow}</tbody>
        </table>
        <div class="result-grid">
          <div style="grid-column:1/-1">
            <h3 style="margin:1rem 0 0.5rem;">楽観性と悲観性の合計得点</h3>
            <div class="chart-wrap chart-small"><canvas id="ops-chart"></canvas></div>
            <div id="ops-values" style="margin-top:0.6rem; font-weight:600; text-align:center;">
              合計（楽観 / 悲観）: ${formatInt(summary.optimism.sum)} / ${formatInt(summary.pessimism.sum)}　
              平均（楽観 / 悲観）: ${formatMean(summary.optimism.mean)} / ${formatMean(summary.pessimism.mean)}
            </div>
            <div class="description-box" style="margin-top:0.8rem;">
              <div class="score-label">楽観性（Optimism）</div>
              <p style="margin:0.2rem 0 0;">
                将来に対して肯定的な期待を持ち，良い結果を期待する傾向。楽観性が高いほど，困難な状況でも前向きに対処しようとする傾向が強いことを示します。
              </p>
              <div class="score-label" style="margin-top:0.6rem;">悲観性（Pessimism）</div>
              <p style="margin:0.2rem 0 0;">
                将来に対して否定的な予期を持ち，悪い結果を期待する傾向。悲観性が高いほど，ネガティブな結果を想定しやすいことを示します。
              </p>
            </div>
          </div>
        </div>
        <div class="small muted" style="margin-top:1rem;">
          注：外山美樹. (2013). 楽観・悲観性尺度の作成ならびに信頼性・妥当性の検討. 心理学研究, 84(3), 256–266. https://doi.org/10.4992/jjpsy.84.256
        </div>
      </div>
    `;
  }

  function renderResultsChart(summary) {
    const canvas = document.getElementById('ops-chart');
    if (!canvas) {
      debugLog('結果グラフ用の canvas が見つかりません');
      return;
    }

    if (window.opsChart && typeof window.opsChart.destroy === 'function') {
      window.opsChart.destroy();
    }

    const optimismScore = Number(summary.optimism.sum) || 0;
    const pessimismScore = Number(summary.pessimism.sum) || 0;

    const valuesEl = document.getElementById('ops-values');
    if (valuesEl) {
      valuesEl.innerText = (
        `合計（楽観 / 悲観）: ${formatInt(optimismScore)} / ${formatInt(pessimismScore)}　` +
        `平均（楽観 / 悲観）: ${formatMean(summary.optimism.mean)} / ${formatMean(summary.pessimism.mean)}`
      );
    }

    window.opsChart = new Chart(canvas.getContext('2d'), {
      type: 'bar',
      data: {
        labels: ['楽観性 (O)', '悲観性 (P)'],
        datasets: [{
          label: '合計得点 (10〜40)',
          data: [optimismScore, pessimismScore],
          backgroundColor: ['rgba(25,118,210,0.85)', 'rgba(211,47,47,0.85)']
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          y: {
            min: 0,
            max: 40,
            ticks: { stepSize: 5 },
            title: { display: true, text: '合計得点 (0〜40)' }
          }
        }
      }
    });

    try {
      window.opsChart.update();
    } catch (error) {
      debugLog('Chart update failed', error);
    }
  }

  function formatInt(value) {
    if (value == null) return '-';
    return Math.round(value).toString();
  }

  function formatMean(value) {
    if (value == null) return '-';
    const numeric = Number(value);
    return Number.isNaN(numeric) ? '-' : numeric.toFixed(2);
  }
})();
  </script>
</body>
</html>
