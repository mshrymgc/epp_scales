<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>成人用エフォートフル・コントロール尺度日本語版</title>
  <link rel="stylesheet" href="/dist/jspsych.css" />
  <link rel="stylesheet" href="/dist/survey.min.css" />
  <style>
    /* ==========================================
       基本スタイル
       ========================================== */
    body {
      font-family: system-ui, sans-serif;
    }

    /* カード型のコンテナ */
    .card {
      background: #fff;
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 1rem;
    }

    /* グリッドレイアウト */
    .grid {
      display: grid;
      gap: 1rem;
    }

    /* 結果画面のグリッド */
    .result-grid {
      display: grid;
      gap: 1.2rem;
      margin-top: 1.5rem;
    }

    /* レスポンシブ: 780px以上で2カラム表示 */
    @media (min-width: 780px) {
      .result-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: start;
      }
    }

    /* ==========================================
       グラフ関連
       ========================================== */
    .chart-wrap {
      position: relative;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }

    .chart-small {
      height: 260px;
      max-height: 320px;
    }

    .chart-wrap canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ==========================================
       テーブルスタイル
       ========================================== */
    table {
      border-collapse: collapse;
      width: 100%;
    }

    th,
    td {
      padding: 0.45rem 0.4rem;
      border-bottom: 1px solid #eee;
      text-align: left;
      font-size: 0.95rem;
    }

    th {
      font-weight: 600;
      background: #fafafa;
    }

    /* ==========================================
       ユーティリティクラス
       ========================================== */
    .small {
      font-size: 0.85rem;
    }

    .muted {
      color: #666;
    }

    /* ==========================================
       ツールチップ（ホバー時の説明表示）
       ========================================== */
    .likert-label-tooltip {
      position: relative;
    }

    .likert-label-tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 0.8rem;
      opacity: 0;
      transition: opacity 0.15s ease;
      pointer-events: none;
      z-index: 10;
    }

    .likert-label-tooltip:hover::after {
      opacity: 1;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="/dist/jspsych.js"></script>
  <script src="/dist/plugin-html-button-response.js"></script>
  <script src="/dist/plugin-survey.js"></script>
  <script src="/dist/plugin-survey-likert.js"></script>
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe@0.5.0/dist/index.browser.min.js"></script>
</head>
<body>
  <div id="jspsych-target"></div>
  <script>
(() => {
  // ==========================================
  // 0. jsPsych の初期化と基本設定
  // ==========================================
  const PROGRESS_LABEL_TEXT = '進捗状況'; // 進捗バーに表示するテキスト
  const PAGE_SIZE = 12; // 1ページに表示する質問数
  const LIKERT_CHOICES = [
    { value: 1, text: '1 = あてはまらない', label: '1', tooltip: 'あてはまらない' },
    { value: 2, text: '2 = あまりあてはまらない', label: '2', tooltip: 'あまりあてはまらない' },
    { value: 3, text: '3 = 少しあてはまる', label: '3', tooltip: '少しあてはまる' },
    { value: 4, text: '4 = あてはまる', label: '4', tooltip: 'あてはまる' }
  ];
  const DEBUG = false; // true にすると処理の流れをコンソールに表示
  const debugLog = (...args) => { if (DEBUG) console.log(...args); };

  const jsPsych = window.jsPsychModule.initJsPsych({
    display_element: 'jspsych-target',
    show_progress_bar: true,
    auto_update_progress_bar: false
  });

  setProgressLabelToJapanese();
  injectResultStyles();

  // ==========================================
  // 1. 尺度項目の定義
  // ==========================================
  const ECSJ = {
    inhibitory_control: [
      { id: 1, text: '自分がそう望むなら，秘密を守るのはたいてい簡単だ。', reverse: false },
      { id: 2, text: '笑い声が適切でないような状況で，笑いを抑えるのは簡単だ。', reverse: false },
      { id: 3, text: '店で魅力的な品物を見かけた時，それを買うのを我慢するのはとても難しい。', reverse: true },
      { id: 4, text: '興奮していてアイディアを表現したい時でも，順番を外れてしゃべることは簡単に我慢できる。', reverse: false },
      { id: 5, text: '望ましくないと信じているのに習慣となっている行動パターンをやめようと決意した時には，たいてい成功する。', reverse: false },
      { id: 6, text: '何かに興奮している時は，起こり得る結果を考える前にそれにすぐ飛びつくのを抑えるのはたいてい難しい。', reverse: true },
      { id: 7, text: '活力に溢れていると感じられる時でも，必要ならば普通たいした苦もなくじっと座っていられる。', reverse: false },
      { id: 8, text: 'しばしば，楽しい活動にふけって責任から逃げることがある。', reverse: true },
      { id: 9, text: '時々，快への衝動（お菓子を食べる，など）を抑えようとすればするほど，そう行動してしまいやすいように思える。', reverse: true },
      { id: 10, text: '食べたり飲んだりすることへの渇望を我慢することはたいてい難しい。', reverse: true },
      { id: 11, text: '不適切なおふざけをしないでいるのは簡単だ', reverse: false },
    ],
    activation_control: [
      { id: 12, text: 'たいてい，実際に期限が来る前に物事（お金の支払い，宿題など）を終わらせる。', reverse: false },
      { id: 13, text: '約束の時間によく遅れる。', reverse: true },
      { id: 14, text: '最後まで実行しない計画をよく立てる。', reverse: true },
      { id: 15, text: '面倒な行動計画でも決定したらすぐに，実行に移す。', reverse: false },
      { id: 16, text: 'やる必要のあることを思いついたら，たいていすぐにそれに取りかかる。', reverse: false },
      { id: 17, text: '気乗りしない時でも，面倒な課題に取り組むことができる。', reverse: false },
      { id: 18, text: '今日中に仕事をやり遂げる充分な時間がある時でさえ，しばしば明日やってしまおうと考えることがある。', reverse: true },
      { id: 19, text: 'もし車や部屋，洗濯物などを掃除したり洗ったりする必要があるのに気づいても，よくそれを明日まで延期してしまう。', reverse: true },
      { id: 20, text: '時間どおりに物事を終わらせることはめったにない。', reverse: true },
      { id: 21, text: 'たいてい。責任は少しでも早く果たそうとする。', reverse: false },
      { id: 22, text: '事態がどうなるか心配な時，たいていその事態に対処することを避けてしまう。', reverse: true },
      { id: 23, text: '課題を，やりたくない時でもやり続けることができる。', reverse: false }
    ],
    attention_control: [
      { id: 24, text: '何かのことで悲しい時，課題に集中し続けるのは難しい。', reverse: true },
      { id: 25, text: '何かの結果について不安になっている時，課題に集中し続けるのはとても苦労する。', reverse: true },
      { id: 26, text: '心悩ませている時，集中するのはとても難しい。', reverse: true },
      { id: 27, text: '近いうちにおこる出来事について嬉しくて興奮している時，集中力を要する課題に注意を向け続けるのはとても苦労する。', reverse: true },
      { id: 28, text: 'とりわけ気分がいい時，複数のことを同時に憶えておくことを必要とする課題に集中するのはとても苦労する。', reverse: true },
      { id: 29, text: '良い報せを聞くと，責任を果たす事に集中できなくなってしまう。', reverse: true },
      { id: 30, text: '集中しようと努力しても，簡単に気が散ってしまう。', reverse: true },
      { id: 31, text: '何かに集中しようとしている時でも，気を散らすような考えの侵入を阻止するのは難しい。', reverse: true },
      { id: 32, text: '何か勉強しようとしている時，周囲の騒音を無視して集中するのは難しい。', reverse: true },
      { id: 33, text: '中断させられたり注意をそらされたりした時，たいていはそれまで自分がやっていたことに注意を向けなおすことができる。', reverse: false },
      { id: 34, text: '通常，周囲で起きている複数の出来事を憶えておくのはとても得意だ。', reverse: false },
      { id: 35, text: 'しばしば，ふたつの異なる課題を交互にやるのは難しい。', reverse: true }
    ]
  };
  
  // ドメインコード
  const DOMAIN_CODES = {
    inhibitory_control: 'IC',
    activation_control: 'AC',
    attention_control: 'AT'
  };

  // 論文で報告された平均値（合計得点）
  const PAPER_MEANS = {
    IC: 29.7,  // 行動抑制の制御（11項目）
    AC: 30.3,  // 行動始発の制御（12項目）
    AT: 27.8,  // 注意の制御（12項目）
    Total: 87.7 // 全体合計（35項目）
  };

  // 合計項目数
  const TOTAL_ITEMS = (
    ECSJ.inhibitory_control.length +
    ECSJ.activation_control.length +
    ECSJ.attention_control.length
  );

  // 参照用ルックアップ（キーはドメインコードと元の項目ID）
  const ITEM_LOOKUP = {
    IC: Object.fromEntries(ECSJ.inhibitory_control.map((item) => [item.id, item])),
    AC: Object.fromEntries(ECSJ.activation_control.map((item) => [item.id, item])),
    AT: Object.fromEntries(ECSJ.attention_control.map((item) => [item.id, item]))
  };

  // システム情報と開始時刻を取得して全トライアルに記録
  const systemInfo = getSystemInfo();
  const startTimestamp = Date.now();
  const startTimeJST = getJapanTime(startTimestamp);
  
  jsPsych.data.addProperties({
    browser: systemInfo.browser,
    os: systemInfo.os,
    user_agent: systemInfo.user_agent,
    start_time_jst: startTimeJST,
    start_timestamp: startTimestamp
  });

  const allItems = createQuestionPool();
  jsPsych.data.addProperties({
    ecsj_item_order: JSON.stringify(allItems.map(({ domain, id, originalId, text }) => ({ domain, id, originalId, text })))
  });
  const pages = chunkArray(allItems, PAGE_SIZE);

  // ==========================================
  // 2. タイムラインの構築
  // ==========================================
  const intro = createIntroTrial();
  const demographics = createDemographicsTrial();
  const likertPages = pages.map((items, index) => createLikertPage(items, index));
  const subjectId = jsPsych.randomization.randomID(10);
  jsPsych.data.addProperties({ subject_id: subjectId });
  const saveDataTrial = createSaveTrial(subjectId);
  let lastSummary = null;
  const results = createResultsTrial();

  const timeline = [intro, demographics, ...likertPages, saveDataTrial, results];
  jsPsych.run(timeline);

  // ==========================================
  // 3. DOM 初期化系関数
  // ==========================================
  function setProgressLabelToJapanese() {
    const trySetLabel = () => {
      const span = document.querySelector('#jspsych-progressbar-container span');
      if (span) {
        span.innerHTML = PROGRESS_LABEL_TEXT;
        return true;
      }
      return false;
    };

    if (trySetLabel()) return;

    const observer = new MutationObserver((_, obs) => {
      if (trySetLabel()) obs.disconnect();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }

  function injectResultStyles() {
    const styleEl = document.createElement('style');
    styleEl.innerHTML = `
      .description-box { background: linear-gradient(90deg,#f5f9ff,#fbfdff); border-left:6px solid #1976D2; padding:1rem; border-radius:6px; }
      .description-box .score-label { font-weight:700; font-size:1rem; color:#0d47a1; margin-bottom:0.25rem; }
      .description-box p { margin:0 0 0.6rem 0; line-height:1.45; }
    `;
    document.head.appendChild(styleEl);
  }

  // ==========================================
  // 4. データ準備ヘルパー
  // ==========================================
  
  /**
   * システム情報を取得する関数
   * ユーザーエージェント文字列からブラウザとOSを判定
   * @returns {Object} browser, os, user_agent を含むオブジェクト
   */
  function getSystemInfo() {
    const ua = navigator.userAgent;
    let browser = 'Unknown';
    let os = 'Unknown';
    
    // ブラウザの判定
    if (ua.indexOf('Edg') > -1) browser = 'Edge';
    else if (ua.indexOf('Chrome') > -1) browser = 'Chrome';
    else if (ua.indexOf('Safari') > -1) browser = 'Safari';
    else if (ua.indexOf('Firefox') > -1) browser = 'Firefox';
    else if (ua.indexOf('Opera') > -1 || ua.indexOf('OPR') > -1) browser = 'Opera';
    
    // OSの判定
    if (ua.indexOf('Win') > -1) os = 'Windows';
    else if (ua.indexOf('Mac') > -1) os = 'macOS';
    else if (ua.indexOf('Linux') > -1) os = 'Linux';
    else if (ua.indexOf('Android') > -1) os = 'Android';
    else if (ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) os = 'iOS';
    
    return { browser, os, user_agent: ua };
  }
  
  /**
   * 日本時間の文字列を取得する関数
   * @param {number} timestamp - タイムスタンプ（ミリ秒）。省略時は現在時刻
   * @returns {string} 日本時間の文字列（例: "2025/10/22 14:30:45"）
   */
  function getJapanTime(timestamp) {
    const date = timestamp ? new Date(timestamp) : new Date();
    return date.toLocaleString('ja-JP', { 
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    }).replace(/\//g, '/').replace(',', '');
  }
  
  function createQuestionPool() {
    const merged = [
      ...ECSJ.inhibitory_control.map((item) => ({
        text: item.text,
        reverse: item.reverse,
        domain: DOMAIN_CODES.inhibitory_control,
        id: item.id,            // ドメイン内IDとして元のIDを使用
        originalId: item.id
      })),
      ...ECSJ.activation_control.map((item) => ({
        text: item.text,
        reverse: item.reverse,
        domain: DOMAIN_CODES.activation_control,
        id: item.id,
        originalId: item.id
      })),
      ...ECSJ.attention_control.map((item) => ({
        text: item.text,
        reverse: item.reverse,
        domain: DOMAIN_CODES.attention_control,
        id: item.id,
        originalId: item.id
      }))
    ];

    return shuffleInPlace(merged);
  }

  function updateProgressBar(fraction) {
    const barInner = document.querySelector('#jspsych-progressbar-inner');
    if (!barInner) return;
    const clamped = Math.max(0, Math.min(1, fraction));
    barInner.style.width = `${Math.round(clamped * 100)}%`;
  }

  function chunkArray(arr, size) {
    const result = [];
    for (let i = 0; i < arr.length; i += size) {
      result.push(arr.slice(i, i + size));
    }
    return result;
  }

  function shuffleInPlace(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // ==========================================
  // 5. トライアル生成ヘルパー
  // ==========================================
  function createIntroTrial() {
    return {
      type: window.jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="card">
          <h2>成人用エフォートフル・コントロール尺度日本語版</h2>
          <h4>「感情・人格心理学」受講者用</h4>
          <p style="margin:0.6rem 0 0;">
            これはエフォートフルコントロールの程度を測定するアンケートであり，講義内容の理解を促進するために利用されます。<br>この結果だけで医学的診断を行ったり，あなたの性格そのものを測定することはできませんので注意してください。<br>データは保管されますが，個人が特定されることはなく，回答の有無が成績に影響することは一切ありません。
          </p>
          <p style="margin:0.6rem 0 0;">
            回答は研究や授業の補助に活用されますが，個人が特定されることはありません。<br>
            また，回答の有無が成績に影響することは一切ありません。
          </p>
          <ul class="small muted" style="margin-top:0.8rem; padding-left:1.2rem;">
            回答時間の目安：5〜10分<br>
            出典：山形伸二,・高橋雄介・繁桝算男・大野裕・木島伸彦. (2005). 成人用エフォートフル・コントロール尺度日本語版の作成とその信頼性・妥当性の検討. パーソナリティ研究, 14(1), 30-41.
          </ul>
        </div>
      `,
      choices: ['開始']
    };
  }

  function createDemographicsTrial() {
    return {
      type: window.jsPsychSurvey,
      survey_json: {
        showQuestionNumbers: false,
        pages: [{
          name: 'demographics',
          elements: [
            {
              type: 'text',
              name: 'age',
              title: '年齢',
              inputType: 'number',
              isRequired: true
            },
            {
              type: 'dropdown',
              name: 'gender',
              title: '性別',
              isRequired: true,
              choices: ['男性','女性','その他','未回答']
            }
          ]
        }],
        pageNextText: '次へ',
        completeText: '次へ'
      },
      on_finish: (data) => {
        const response = data.response || {};
        jsPsych.data.addProperties({
          age: response.age || '',
          gender: response.gender || ''
        });
      }
    };
  }

  function createLikertPage(items, pageIndex) {
    const pageStart = pageIndex * PAGE_SIZE + 1;
    const pageEnd = pageStart + items.length - 1;
    const isLastPage = pageIndex === pages.length - 1;

    return {
      type: window.jsPsychSurveyLikert,
      preamble: `
        <div class="card">
          <b>質問 ${pageStart}–${pageEnd} / ${TOTAL_ITEMS}</b>
          <p style="margin:0.5rem 0 0;">
            以下の各文章は，あなたにどのくらいあてはまりますか。<br>最も適当なものを一つ選んでください。
          </p>
          <p style="margin:0.5rem 0 0; font-size:0.9rem; color:#555;">
            ${LIKERT_CHOICES.map(c => `<strong>${c.label}</strong> = ${c.tooltip}`).join('　/　')}
          </p>
        </div>
      `,
      questions: items.map(item => ({
        prompt: item.text,
        labels: LIKERT_CHOICES.map(c => c.label), // ['1', '2', '3', '4']
        name: `${item.domain}${item.id}`,
        required: true
      })),
      button_label: isLastPage ? '結果を見る' : '次へ',
      on_load: () => {
        debugLog('Loaded ECSJ survey-likert page', { pageIndex, pageStart, pageEnd });
        updateProgressBar(pageEnd / TOTAL_ITEMS);
        
        // ツールチップを追加
        setTimeout(() => {
          const labels = document.querySelectorAll('.jspsych-survey-likert-opts label');
          labels.forEach((label, index) => {
            const choiceIndex = index % LIKERT_CHOICES.length;
            const tooltip = LIKERT_CHOICES[choiceIndex].tooltip;
            label.classList.add('likert-label-tooltip');
            label.setAttribute('data-tooltip', tooltip);
          });
        }, 100);
      },
      on_finish: (data) => {
        // ページ番号を記録（1-based）
        data.page_number = pageIndex + 1;

        // このページで回答した項目のリスト（例: "IC1,AC13,AT30"...）
        const pageItemsList = items.map(item => `${item.domain}${item.id}`).join(',');
        data.page_items = pageItemsList;

        // 各回答について逆転項目を考慮した得点を記録
        const resp = data.response || {};
        Object.entries(resp).forEach(([name, idx0]) => {
          // 該当項目を検索
          const item = items.find(it => `${it.domain}${it.id}` === name);
          if (!item) return;

          // survey-likert は 0–3 のインデックスを返す → 1–4 に補正
          const rawIndex = typeof idx0 === 'number' ? idx0 : Number(idx0);
          if (!Number.isFinite(rawIndex)) return;
          const rawScore = rawIndex + 1; // 1–4

          // 範囲チェック
          if (rawScore < 1 || rawScore > 4) return;

          // 逆転処理（4件法は 5 - 値）
          const scoredValue = item.reverse ? (5 - rawScore) : rawScore;

          // CSVに記録する変数を追加
          data[`${name}_raw`] = rawScore;                 // 生得点（1–4）
          data[`${name}_scored`] = scoredValue;          // 逆転処理済み得点
          data[`${name}_reversed`] = item.reverse;       // 逆転項目フラグ
          data[`${name}_original_id`] = item.originalId; // 元の項目番号
        });

        debugLog('Page finished (survey-likert)', { pageIndex, pageItemsList });
      }
    };
  }

  function createSaveTrial(subjectId) {
    return {
      type: window.jsPsychPipe,
      action: 'save',
      experiment_id: '4MLKGxDsTk6n',
      filename: `${subjectId}.csv`,
      data_string: () => jsPsych.data.get().csv()
    };
  }

  function createResultsTrial() {
    return {
      type: window.jsPsychHtmlButtonResponse,
      stimulus: () => {
        const summary = computeSummary();
        lastSummary = summary;
        return createResultsHtml(summary);
      },
      choices: ['終了'],
      on_finish: () => {
        // 終了時刻と所要時間を記録
        const endTimestamp = Date.now();
        const endTimeJST = getJapanTime(endTimestamp);
        const durationMs = endTimestamp - startTimestamp;
        const durationSec = durationMs / 1000;
        const durationMin = durationSec / 60;
        
        // 全データに終了時刻と所要時間を追加
        jsPsych.data.addProperties({
          end_time_jst: endTimeJST,
          end_timestamp: endTimestamp,
          total_duration_ms: durationMs,
          total_duration_sec: parseFloat(durationSec.toFixed(2)),
          total_duration_min: parseFloat(durationMin.toFixed(2))
        });
        
        window.location.href = 'https://mshrymgc.github.io/epp_scales/';
      },
      on_load: () => {
        if (!lastSummary) {
          debugLog('結果表示のための集計が見つかりません');
          return;
        }
        renderResultsChart(lastSummary);
      }
    };
  }

  // ==========================================
  // 6. 回答処理ロジック
  // ==========================================
  function getResponses() {
    const responses = { IC: {}, AC: {}, AT: {} };

    const surveyTrials = jsPsych.data.get()
      .filter(trial => trial.trial_type && (trial.trial_type === 'survey-likert' || trial.trial_type === 'survey'))
      .values();

    surveyTrials.forEach((trial, trialIndex) => {
      const trialResponse = trial.response || {};
      debugLog(`Trial ${trialIndex}`, trialResponse);

      Object.entries(trialResponse).forEach(([name, value]) => {
        const match = /^(IC|AC|AT)(\d+)$/.exec(String(name));
        if (!match) return;

        const domain = match[1];
        const id = Number(match[2]);
        const numeric = parseLikertValue(value);
        if (numeric == null) return;

        responses[domain][id] = numeric;
      });
    });

    debugLog('Collected responses', responses);
    return responses;
  }

  function parseLikertValue(value) {
    if (typeof value === 'number' && Number.isFinite(value)) {
      // survey-likert プラグインは 0 始まりのインデックスを返すため補正（4件法: 0-3 → 1-4）
      if (value >= 0 && value <= 3) return value + 1;
      return value;
    }
    if (typeof value === 'string') {
      const parsed = Number(value);
      return Number.isNaN(parsed) ? null : parsed;
    }
    if (value && typeof value === 'object') {
      if ('value' in value) {
        return parseLikertValue(value.value);
      }
      const fallback = parseInt(JSON.stringify(value), 10);
      return Number.isNaN(fallback) ? null : fallback;
    }
    return null;
  }

  function computeSummary() {
    const responses = getResponses();
    const base = {
      inhibitory_control: { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0] },
      activation_control: { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0] },
      attention_control:  { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0] },
      total:              { sum: 0, count: 0, mean: null, counts: [0, 0, 0, 0] }
    };

    const domainOrder = [
      { code: 'IC', key: 'inhibitory_control' },
      { code: 'AC', key: 'activation_control' },
      { code: 'AT', key: 'attention_control' }
    ];

    domainOrder.forEach(({ code, key }) => {
      const store = base[key];
      const domainResponses = responses[code] || {};

      Object.entries(domainResponses).forEach(([idStr, rawValue]) => {
        const id = Number(idStr);
        if (!Number.isFinite(id)) return;

        const raw = Number(rawValue);
        if (!Number.isFinite(raw)) return;

        const meta = findItem(code, id);
        const scored = meta && meta.reverse ? 5 - raw : raw; // 4件法 → 逆転は (5 - raw)

        store.count += 1;
        base.total.count += 1;
        if (raw >= 1 && raw <= 4) {
          store.counts[raw - 1] += 1;
          base.total.counts[raw - 1] += 1;
        }
        store.sum += scored;
        base.total.sum += scored;
      });

      if (store.count > 0) store.mean = store.sum / store.count;
    });

    if (base.total.count > 0) base.total.mean = base.total.sum / base.total.count;

    debugLog('Summary result', base);
    return base;
  }

  function findItem(domain, id) {
    return ITEM_LOOKUP[domain]?.[id] || null;
  }

  // ==========================================
  // 7. 表示用ユーティリティ
  // ==========================================
  function createResultsHtml(summary) {
    const icRow = `<tr><td>行動抑制の制御</td><td>${formatInt(summary.inhibitory_control.sum)} / 44</td><td>${formatMean(summary.inhibitory_control.mean)}</td><td>${formatMean(PAPER_MEANS.IC)}</td></tr>`;
    const acRow = `<tr><td>行動始発の制御</td><td>${formatInt(summary.activation_control.sum)} / 48</td><td>${formatMean(summary.activation_control.mean)}</td><td>${formatMean(PAPER_MEANS.AC)}</td></tr>`;
    const attRow = `<tr><td>注意の制御</td><td>${formatInt(summary.attention_control.sum)} / 48</td><td>${formatMean(summary.attention_control.mean)}</td><td>${formatMean(PAPER_MEANS.AT)}</td></tr>`;
    const totalRow = `<tr><td>全体合計</td><td>${formatInt(summary.total.sum)} / 140</td><td>${formatMean(summary.total.mean)}</td><td>${formatMean(PAPER_MEANS.Total)}</td></tr>`;

    return `
      <div style="max-width:960px; margin:0 auto; padding:1rem;">
        <h2 style="text-align:center; margin-bottom:1.5rem;">あなたの結果</h2>
        
        <div class="grid" style="gap:1.5rem;">
          <!-- レーダーチャート: 3下位尺度の比較 -->
          <div class="card">
            <h3 style="margin:0 0 1rem;">下位尺度の比較（レーダーチャート）</h3>
            <div class="chart-wrap">
              <canvas id="ecsj-radar-chart"></canvas>
            </div>
            <p class="small muted" style="margin-top:0.8rem; text-align:center;">
              青: あなたの得点 | 赤: 論文平均値
            </p>
          </div>

          <!-- バーチャート: 全体合計の比較 -->
          <div class="card">
            <h3 style="margin:0 0 1rem;">全体合計の比較（バーチャート）</h3>
            <div class="chart-wrap">
              <canvas id="ecsj-bar-chart"></canvas>
            </div>
            <p class="small muted" style="margin-top:0.8rem; text-align:center;">
              あなたの合計: ${formatInt(summary.total.sum)} / 論文平均: ${formatMean(PAPER_MEANS.Total)}
            </p>
          </div>

          <!-- 結果テーブル -->
          <div class="card">
            <h3 style="margin:0 0 1rem;">詳細スコア</h3>
            <table>
              <thead>
                <tr>
                  <th>下位尺度</th>
                  <th>合計得点</th>
                  <th>平均</th>
                  <th>論文平均</th>
                </tr>
              </thead>
              <tbody>
                ${icRow}
                ${acRow}
                ${attRow}
                ${totalRow}
              </tbody>
            </table>
          </div>

          <!-- 説明 -->
          <div class="card">
            <div class="description-box">
              <div class="score-label">行動抑制の制御（Inhibitory Control）</div>
              <p style="margin:0.2rem 0 0;">
                不適切な接近行動を抑制する能力
              </p><br>
              <div class="score-label" style="margin-top:0.6rem;">行動始発の制御（Activation Control）</div>
              <p style="margin:0.2rem 0 0;">
                ある行動を回避したい時でもそれを遂行する能力
              </p><br>
              <div class="score-label" style="margin-top:0.6rem;">注意の制御（Attention Control）</div>
              <p style="margin:0.2rem 0 0;">
                必要に応じて，集中したり注意を切り替えたりする能力
              </p>
            </div>
          </div>
        </div>

        <p class="small muted" style="margin-top:1.5rem; text-align:center;">
          ※ 論文平均は山形他 (2005) のTable 1の値を使用。下位尺度ごとの項目を確認したい場合は，論文を参照してください。
        </p>
      </div>
    `;
  }

  function renderResultsChart(summary) {
    const icScore = Number(summary.inhibitory_control.sum) || 0;
    const acScore = Number(summary.activation_control.sum) || 0;
    const attScore = Number(summary.attention_control.sum) || 0;
    const totalScore = Number(summary.total.sum) || 0;

    // レーダーチャート: 3下位尺度
    const radarCanvas = document.getElementById('ecsj-radar-chart');
    if (radarCanvas) {
      if (window.ecsjRadarChart && typeof window.ecsjRadarChart.destroy === 'function') {
        window.ecsjRadarChart.destroy();
      }

      window.ecsjRadarChart = new Chart(radarCanvas.getContext('2d'), {
        type: 'radar',
        data: {
          labels: ['行動抑制の制御', '行動始発の制御', '注意の制御'],
          datasets: [
            {
              label: 'あなたの得点',
              data: [icScore, acScore, attScore],
              backgroundColor: 'rgba(25,118,210,0.2)',
              borderColor: 'rgba(25,118,210,1)',
              pointBackgroundColor: 'rgba(25,118,210,1)',
              pointBorderColor: '#fff',
              pointHoverBackgroundColor: '#fff',
              pointHoverBorderColor: 'rgba(25,118,210,1)'
            },
            {
              label: '論文平均',
              data: [PAPER_MEANS.IC, PAPER_MEANS.AC, PAPER_MEANS.AT],
              backgroundColor: 'rgba(229,57,53,0.2)',
              borderColor: 'rgba(229,57,53,1)',
              pointBackgroundColor: 'rgba(229,57,53,1)',
              pointBorderColor: '#fff',
              pointHoverBackgroundColor: '#fff',
              pointHoverBorderColor: 'rgba(229,57,53,1)'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            r: {
              beginAtZero: true,
              max: 48,
              ticks: {
                stepSize: 12
              }
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top'
            }
          }
        }
      });
    }

    // バーチャート: 全体合計
    const barCanvas = document.getElementById('ecsj-bar-chart');
    if (barCanvas) {
      if (window.ecsjBarChart && typeof window.ecsjBarChart.destroy === 'function') {
        window.ecsjBarChart.destroy();
      }

      window.ecsjBarChart = new Chart(barCanvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels: ['あなたの合計', '論文平均'],
          datasets: [{
            label: '全体合計得点',
            data: [totalScore, PAPER_MEANS.Total],
            backgroundColor: ['rgba(25,118,210,0.85)', 'rgba(229,57,53,0.85)'],
            borderColor: ['rgba(25,118,210,1)', 'rgba(229,57,53,1)'],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            y: {
              beginAtZero: true,
              max: 140,
              ticks: {
                stepSize: 20
              }
            }
          },
          plugins: {
            legend: {
              display: false
            }
          }
        }
      });
    }

    debugLog('Charts rendered', { icScore, acScore, attScore, totalScore });
  }

  function formatInt(value) {
    if (value == null) return '-';
    return Math.round(value).toString();
  }

  function formatMean(value) {
    if (value == null) return '-';
    const numeric = Number(value);
    return Number.isNaN(numeric) ? '-' : numeric.toFixed(2);
  }
})();
  </script>
</body>
</html>
